/*
HW Mux Reservation System

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.26.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hwmux

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// ReservationsAPIService ReservationsAPI service
type ReservationsAPIService service

type ApiReservationsActionableListRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	maxHistory *time.Time
	ordering *string
	owner *int32
	page *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsActionableListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsActionableListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsActionableListRequest) ADevices(aDevices []int32) ApiReservationsActionableListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsActionableListRequest) CancelExisting(cancelExisting bool) ApiReservationsActionableListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsActionableListRequest) Details(details string) ApiReservationsActionableListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsActionableListRequest) Device(device float32) ApiReservationsActionableListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsActionableListRequest) DeviceGroup(deviceGroup float32) ApiReservationsActionableListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsActionableListRequest) Id(id string) ApiReservationsActionableListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsActionableListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsActionableListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsActionableListRequest) InvertPriority(invertPriority bool) ApiReservationsActionableListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsActionableListRequest) Label(label float32) ApiReservationsActionableListRequest {
	r.label = &label
	return r
}

// Filter out reservations that expired before the specified datetime. Defaults to 24 hours prior.
func (r ApiReservationsActionableListRequest) MaxHistory(maxHistory time.Time) ApiReservationsActionableListRequest {
	r.maxHistory = &maxHistory
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsActionableListRequest) Ordering(ordering string) ApiReservationsActionableListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsActionableListRequest) Owner(owner int32) ApiReservationsActionableListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsActionableListRequest) Page(page int32) ApiReservationsActionableListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsActionableListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsActionableListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsActionableListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsActionableListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsActionableListRequest) RDevices(rDevices []int32) ApiReservationsActionableListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsActionableListRequest) Search(search string) ApiReservationsActionableListRequest {
	r.search = &search
	return r
}

func (r ApiReservationsActionableListRequest) Status(status string) ApiReservationsActionableListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsActionableListRequest) TCompleted(tCompleted time.Time) ApiReservationsActionableListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsActionableListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsActionableListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsActionableListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsActionableListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsActionableListRequest) TRequested(tRequested time.Time) ApiReservationsActionableListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsActionableListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsActionableListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsActionableListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsActionableListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsActionableListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsActionableListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsActionableListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsActionableListRequest) UseWatchdog(useWatchdog bool) ApiReservationsActionableListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsActionableListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsActionableListExecute(r)
}

/*
ReservationsActionableList Method for ReservationsActionableList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsActionableListRequest
*/
func (a *ReservationsAPIService) ReservationsActionableList(ctx context.Context) ApiReservationsActionableListRequest {
	return ApiReservationsActionableListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsAPIService) ReservationsActionableListExecute(r ApiReservationsActionableListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsActionableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/actionable/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", t, "multi")
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", t, "multi")
		}
	}
	if r.cancelExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancel_existing", r.cancelExisting, "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "")
	}
	if r.deviceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_group", r.deviceGroup, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.includeResourceData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_resource_data", r.includeResourceData, "")
	} else {
		var defaultValue bool = false
		r.includeResourceData = &defaultValue
	}
	if r.invertPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invert_priority", r.invertPriority, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.maxHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_history", r.maxHistory, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", t, "multi")
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", t, "multi")
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", t, "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.tCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed", r.tCompleted, "")
	}
	if r.tCompletedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__after", r.tCompletedAfter, "")
	}
	if r.tCompletedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__before", r.tCompletedBefore, "")
	}
	if r.tCompletedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__isnull", r.tCompletedIsnull, "")
	}
	if r.tLeaseExpires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires", r.tLeaseExpires, "")
	}
	if r.tLeaseExpiresAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__after", r.tLeaseExpiresAfter, "")
	}
	if r.tLeaseExpiresBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__before", r.tLeaseExpiresBefore, "")
	}
	if r.tLeaseExpiresIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__isnull", r.tLeaseExpiresIsnull, "")
	}
	if r.tRequested != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested", r.tRequested, "")
	}
	if r.tRequestedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__after", r.tRequestedAfter, "")
	}
	if r.tRequestedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__before", r.tRequestedBefore, "")
	}
	if r.tSatisfied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied", r.tSatisfied, "")
	}
	if r.tSatisfiedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__after", r.tSatisfiedAfter, "")
	}
	if r.tSatisfiedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__before", r.tSatisfiedBefore, "")
	}
	if r.tSatisfiedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__isnull", r.tSatisfiedIsnull, "")
	}
	if r.useWatchdog != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_watchdog", r.useWatchdog, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsActiveListRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	maxHistory *time.Time
	ordering *string
	owner *int32
	page *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsActiveListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsActiveListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsActiveListRequest) ADevices(aDevices []int32) ApiReservationsActiveListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsActiveListRequest) CancelExisting(cancelExisting bool) ApiReservationsActiveListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsActiveListRequest) Details(details string) ApiReservationsActiveListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsActiveListRequest) Device(device float32) ApiReservationsActiveListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsActiveListRequest) DeviceGroup(deviceGroup float32) ApiReservationsActiveListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsActiveListRequest) Id(id string) ApiReservationsActiveListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsActiveListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsActiveListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsActiveListRequest) InvertPriority(invertPriority bool) ApiReservationsActiveListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsActiveListRequest) Label(label float32) ApiReservationsActiveListRequest {
	r.label = &label
	return r
}

// Filter out reservations that expired before the specified datetime. Defaults to 24 hours prior.
func (r ApiReservationsActiveListRequest) MaxHistory(maxHistory time.Time) ApiReservationsActiveListRequest {
	r.maxHistory = &maxHistory
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsActiveListRequest) Ordering(ordering string) ApiReservationsActiveListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsActiveListRequest) Owner(owner int32) ApiReservationsActiveListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsActiveListRequest) Page(page int32) ApiReservationsActiveListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsActiveListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsActiveListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsActiveListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsActiveListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsActiveListRequest) RDevices(rDevices []int32) ApiReservationsActiveListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsActiveListRequest) Search(search string) ApiReservationsActiveListRequest {
	r.search = &search
	return r
}

func (r ApiReservationsActiveListRequest) Status(status string) ApiReservationsActiveListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsActiveListRequest) TCompleted(tCompleted time.Time) ApiReservationsActiveListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsActiveListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsActiveListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsActiveListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsActiveListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsActiveListRequest) TRequested(tRequested time.Time) ApiReservationsActiveListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsActiveListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsActiveListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsActiveListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsActiveListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsActiveListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsActiveListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsActiveListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsActiveListRequest) UseWatchdog(useWatchdog bool) ApiReservationsActiveListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsActiveListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsActiveListExecute(r)
}

/*
ReservationsActiveList Method for ReservationsActiveList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsActiveListRequest
*/
func (a *ReservationsAPIService) ReservationsActiveList(ctx context.Context) ApiReservationsActiveListRequest {
	return ApiReservationsActiveListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsAPIService) ReservationsActiveListExecute(r ApiReservationsActiveListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsActiveList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/active/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", t, "multi")
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", t, "multi")
		}
	}
	if r.cancelExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancel_existing", r.cancelExisting, "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "")
	}
	if r.deviceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_group", r.deviceGroup, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.includeResourceData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_resource_data", r.includeResourceData, "")
	} else {
		var defaultValue bool = false
		r.includeResourceData = &defaultValue
	}
	if r.invertPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invert_priority", r.invertPriority, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.maxHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_history", r.maxHistory, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", t, "multi")
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", t, "multi")
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", t, "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.tCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed", r.tCompleted, "")
	}
	if r.tCompletedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__after", r.tCompletedAfter, "")
	}
	if r.tCompletedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__before", r.tCompletedBefore, "")
	}
	if r.tCompletedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__isnull", r.tCompletedIsnull, "")
	}
	if r.tLeaseExpires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires", r.tLeaseExpires, "")
	}
	if r.tLeaseExpiresAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__after", r.tLeaseExpiresAfter, "")
	}
	if r.tLeaseExpiresBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__before", r.tLeaseExpiresBefore, "")
	}
	if r.tLeaseExpiresIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__isnull", r.tLeaseExpiresIsnull, "")
	}
	if r.tRequested != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested", r.tRequested, "")
	}
	if r.tRequestedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__after", r.tRequestedAfter, "")
	}
	if r.tRequestedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__before", r.tRequestedBefore, "")
	}
	if r.tSatisfied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied", r.tSatisfied, "")
	}
	if r.tSatisfiedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__after", r.tSatisfiedAfter, "")
	}
	if r.tSatisfiedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__before", r.tSatisfiedBefore, "")
	}
	if r.tSatisfiedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__isnull", r.tSatisfiedIsnull, "")
	}
	if r.useWatchdog != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_watchdog", r.useWatchdog, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsCancelUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
}

func (r ApiReservationsCancelUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsCancelUpdateExecute(r)
}

/*
ReservationsCancelUpdate Method for ReservationsCancelUpdate

Release the reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsCancelUpdateRequest
*/
func (a *ReservationsAPIService) ReservationsCancelUpdate(ctx context.Context, id string) ApiReservationsCancelUpdateRequest {
	return ApiReservationsCancelUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsCancelUpdateExecute(r ApiReservationsCancelUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsCancelUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsCreateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	reservationRequest *ReservationRequest
}

func (r ApiReservationsCreateRequest) ReservationRequest(reservationRequest ReservationRequest) ApiReservationsCreateRequest {
	r.reservationRequest = &reservationRequest
	return r
}

func (r ApiReservationsCreateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsCreateExecute(r)
}

/*
ReservationsCreate Method for ReservationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsCreateRequest
*/
func (a *ReservationsAPIService) ReservationsCreate(ctx context.Context) ApiReservationsCreateRequest {
	return ApiReservationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsCreateExecute(r ApiReservationsCreateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsListRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	ordering *string
	owner *int32
	page *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsListRequest) ADevices(aDevices []int32) ApiReservationsListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsListRequest) CancelExisting(cancelExisting bool) ApiReservationsListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsListRequest) Details(details string) ApiReservationsListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsListRequest) Device(device float32) ApiReservationsListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsListRequest) DeviceGroup(deviceGroup float32) ApiReservationsListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsListRequest) Id(id string) ApiReservationsListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsListRequest) InvertPriority(invertPriority bool) ApiReservationsListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsListRequest) Label(label float32) ApiReservationsListRequest {
	r.label = &label
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsListRequest) Ordering(ordering string) ApiReservationsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsListRequest) Owner(owner int32) ApiReservationsListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsListRequest) Page(page int32) ApiReservationsListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsListRequest) RDevices(rDevices []int32) ApiReservationsListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsListRequest) Search(search string) ApiReservationsListRequest {
	r.search = &search
	return r
}

func (r ApiReservationsListRequest) Status(status string) ApiReservationsListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsListRequest) TCompleted(tCompleted time.Time) ApiReservationsListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsListRequest) TRequested(tRequested time.Time) ApiReservationsListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsListRequest) UseWatchdog(useWatchdog bool) ApiReservationsListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsListExecute(r)
}

/*
ReservationsList Method for ReservationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsListRequest
*/
func (a *ReservationsAPIService) ReservationsList(ctx context.Context) ApiReservationsListRequest {
	return ApiReservationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsAPIService) ReservationsListExecute(r ApiReservationsListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_device_groups", t, "multi")
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "a_devices", t, "multi")
		}
	}
	if r.cancelExisting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancel_existing", r.cancelExisting, "")
	}
	if r.details != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "details", r.details, "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "")
	}
	if r.deviceGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_group", r.deviceGroup, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.includeResourceData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_resource_data", r.includeResourceData, "")
	} else {
		var defaultValue bool = false
		r.includeResourceData = &defaultValue
	}
	if r.invertPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invert_priority", r.invertPriority, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	if r.owner != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_group_labels", t, "multi")
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_device_groups", t, "multi")
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "r_devices", t, "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.tCompleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed", r.tCompleted, "")
	}
	if r.tCompletedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__after", r.tCompletedAfter, "")
	}
	if r.tCompletedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__before", r.tCompletedBefore, "")
	}
	if r.tCompletedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_completed__isnull", r.tCompletedIsnull, "")
	}
	if r.tLeaseExpires != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires", r.tLeaseExpires, "")
	}
	if r.tLeaseExpiresAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__after", r.tLeaseExpiresAfter, "")
	}
	if r.tLeaseExpiresBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__before", r.tLeaseExpiresBefore, "")
	}
	if r.tLeaseExpiresIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_lease_expires__isnull", r.tLeaseExpiresIsnull, "")
	}
	if r.tRequested != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested", r.tRequested, "")
	}
	if r.tRequestedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__after", r.tRequestedAfter, "")
	}
	if r.tRequestedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_requested__before", r.tRequestedBefore, "")
	}
	if r.tSatisfied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied", r.tSatisfied, "")
	}
	if r.tSatisfiedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__after", r.tSatisfiedAfter, "")
	}
	if r.tSatisfiedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__before", r.tSatisfiedBefore, "")
	}
	if r.tSatisfiedIsnull != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t_satisfied__isnull", r.tSatisfiedIsnull, "")
	}
	if r.useWatchdog != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_watchdog", r.useWatchdog, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsMetadataPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
	requestBody *map[string]interface{}
}

func (r ApiReservationsMetadataPartialUpdateRequest) RequestBody(requestBody map[string]interface{}) ApiReservationsMetadataPartialUpdateRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiReservationsMetadataPartialUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsMetadataPartialUpdateExecute(r)
}

/*
ReservationsMetadataPartialUpdate Method for ReservationsMetadataPartialUpdate

Update the reservation metadata. Use PUT to replace the existing data
entirely and PATCH to update without deleting existing values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsMetadataPartialUpdateRequest
*/
func (a *ReservationsAPIService) ReservationsMetadataPartialUpdate(ctx context.Context, id string) ApiReservationsMetadataPartialUpdateRequest {
	return ApiReservationsMetadataPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsMetadataPartialUpdateExecute(r ApiReservationsMetadataPartialUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsMetadataPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsMetadataUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
	requestBody *map[string]interface{}
}

func (r ApiReservationsMetadataUpdateRequest) RequestBody(requestBody map[string]interface{}) ApiReservationsMetadataUpdateRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiReservationsMetadataUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsMetadataUpdateExecute(r)
}

/*
ReservationsMetadataUpdate Method for ReservationsMetadataUpdate

Update the reservation metadata. Use PUT to replace the existing data
entirely and PATCH to update without deleting existing values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsMetadataUpdateRequest
*/
func (a *ReservationsAPIService) ReservationsMetadataUpdate(ctx context.Context, id string) ApiReservationsMetadataUpdateRequest {
	return ApiReservationsMetadataUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsMetadataUpdateExecute(r ApiReservationsMetadataUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsMetadataUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsReleaseUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
}

func (r ApiReservationsReleaseUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsReleaseUpdateExecute(r)
}

/*
ReservationsReleaseUpdate Method for ReservationsReleaseUpdate

Release the reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsReleaseUpdateRequest
*/
func (a *ReservationsAPIService) ReservationsReleaseUpdate(ctx context.Context, id string) ApiReservationsReleaseUpdateRequest {
	return ApiReservationsReleaseUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsReleaseUpdateExecute(r ApiReservationsReleaseUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsReleaseUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/release/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsRetrieveRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
}

func (r ApiReservationsRetrieveRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsRetrieveExecute(r)
}

/*
ReservationsRetrieve Method for ReservationsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsRetrieveRequest
*/
func (a *ReservationsAPIService) ReservationsRetrieve(ctx context.Context, id string) ApiReservationsRetrieveRequest {
	return ApiReservationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsRetrieveExecute(r ApiReservationsRetrieveRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsAPIService
	id string
}

func (r ApiReservationsUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsUpdateExecute(r)
}

/*
ReservationsUpdate Method for ReservationsUpdate

Check queue status or renew lease if reservation is ongoing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsUpdateRequest
*/
func (a *ReservationsAPIService) ReservationsUpdate(ctx context.Context, id string) ApiReservationsUpdateRequest {
	return ApiReservationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsAPIService) ReservationsUpdateExecute(r ApiReservationsUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsAPIService.ReservationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
