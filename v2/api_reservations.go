/*
HW Mux Reservation System

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.37.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hwmux

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// ReservationsApiService ReservationsApi service
type ReservationsApiService service

type ApiReservationsActionableListRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	leaseDurationS *int32
	maxHistory *time.Time
	ordering *string
	owner *int32
	page *int32
	queuePosition *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	state *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tQueuePositionUpdated *time.Time
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsActionableListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsActionableListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsActionableListRequest) ADevices(aDevices []int32) ApiReservationsActionableListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsActionableListRequest) CancelExisting(cancelExisting bool) ApiReservationsActionableListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsActionableListRequest) Details(details string) ApiReservationsActionableListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsActionableListRequest) Device(device float32) ApiReservationsActionableListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsActionableListRequest) DeviceGroup(deviceGroup float32) ApiReservationsActionableListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsActionableListRequest) Id(id string) ApiReservationsActionableListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsActionableListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsActionableListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsActionableListRequest) InvertPriority(invertPriority bool) ApiReservationsActionableListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsActionableListRequest) Label(label float32) ApiReservationsActionableListRequest {
	r.label = &label
	return r
}

func (r ApiReservationsActionableListRequest) LeaseDurationS(leaseDurationS int32) ApiReservationsActionableListRequest {
	r.leaseDurationS = &leaseDurationS
	return r
}

// Filter out reservations that expired before the specified datetime. Defaults to 24 hours prior.
func (r ApiReservationsActionableListRequest) MaxHistory(maxHistory time.Time) ApiReservationsActionableListRequest {
	r.maxHistory = &maxHistory
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsActionableListRequest) Ordering(ordering string) ApiReservationsActionableListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsActionableListRequest) Owner(owner int32) ApiReservationsActionableListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsActionableListRequest) Page(page int32) ApiReservationsActionableListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsActionableListRequest) QueuePosition(queuePosition int32) ApiReservationsActionableListRequest {
	r.queuePosition = &queuePosition
	return r
}

func (r ApiReservationsActionableListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsActionableListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsActionableListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsActionableListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsActionableListRequest) RDevices(rDevices []int32) ApiReservationsActionableListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsActionableListRequest) Search(search string) ApiReservationsActionableListRequest {
	r.search = &search
	return r
}

// * &#x60;CRE_PEND&#x60; - create_pending * &#x60;QUE&#x60; - queued * &#x60;RES_PEND&#x60; - reservation_pending * &#x60;ACT&#x60; - active * &#x60;CAN_PEND&#x60; - cancel_pending * &#x60;REL_PEND&#x60; - release_pending * &#x60;FIN&#x60; - finished * &#x60;EXP_PEND&#x60; - expire_pending * &#x60;EXP&#x60; - expired * &#x60;FAIL&#x60; - failed
func (r ApiReservationsActionableListRequest) State(state string) ApiReservationsActionableListRequest {
	r.state = &state
	return r
}

// * &#x60;ACT&#x60; - Active * &#x60;FIN&#x60; - Finished * &#x60;QUE&#x60; - Queued * &#x60;EXP&#x60; - Expired * &#x60;&#x60; - Any
func (r ApiReservationsActionableListRequest) Status(status string) ApiReservationsActionableListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsActionableListRequest) TCompleted(tCompleted time.Time) ApiReservationsActionableListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsActionableListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsActionableListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsActionableListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsActionableListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsActionableListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsActionableListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsActionableListRequest) TQueuePositionUpdated(tQueuePositionUpdated time.Time) ApiReservationsActionableListRequest {
	r.tQueuePositionUpdated = &tQueuePositionUpdated
	return r
}

func (r ApiReservationsActionableListRequest) TRequested(tRequested time.Time) ApiReservationsActionableListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsActionableListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsActionableListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsActionableListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsActionableListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsActionableListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsActionableListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsActionableListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsActionableListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsActionableListRequest) UseWatchdog(useWatchdog bool) ApiReservationsActionableListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsActionableListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsActionableListExecute(r)
}

/*
ReservationsActionableList Method for ReservationsActionableList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsActionableListRequest
*/
func (a *ReservationsApiService) ReservationsActionableList(ctx context.Context) ApiReservationsActionableListRequest {
	return ApiReservationsActionableListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsApiService) ReservationsActionableListExecute(r ApiReservationsActionableListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsActionableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/actionable/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_devices", parameterToString(t, "multi"))
		}
	}
	if r.cancelExisting != nil {
		localVarQueryParams.Add("cancel_existing", parameterToString(*r.cancelExisting, ""))
	}
	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.deviceGroup != nil {
		localVarQueryParams.Add("device_group", parameterToString(*r.deviceGroup, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.includeResourceData != nil {
		localVarQueryParams.Add("include_resource_data", parameterToString(*r.includeResourceData, ""))
	}
	if r.invertPriority != nil {
		localVarQueryParams.Add("invert_priority", parameterToString(*r.invertPriority, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.leaseDurationS != nil {
		localVarQueryParams.Add("lease_duration_s", parameterToString(*r.leaseDurationS, ""))
	}
	if r.maxHistory != nil {
		localVarQueryParams.Add("max_history", parameterToString(*r.maxHistory, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.queuePosition != nil {
		localVarQueryParams.Add("queue_position", parameterToString(*r.queuePosition, ""))
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_group_labels", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_group_labels", parameterToString(t, "multi"))
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_devices", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.tCompleted != nil {
		localVarQueryParams.Add("t_completed", parameterToString(*r.tCompleted, ""))
	}
	if r.tCompletedAfter != nil {
		localVarQueryParams.Add("t_completed__after", parameterToString(*r.tCompletedAfter, ""))
	}
	if r.tCompletedBefore != nil {
		localVarQueryParams.Add("t_completed__before", parameterToString(*r.tCompletedBefore, ""))
	}
	if r.tCompletedIsnull != nil {
		localVarQueryParams.Add("t_completed__isnull", parameterToString(*r.tCompletedIsnull, ""))
	}
	if r.tLeaseExpires != nil {
		localVarQueryParams.Add("t_lease_expires", parameterToString(*r.tLeaseExpires, ""))
	}
	if r.tLeaseExpiresAfter != nil {
		localVarQueryParams.Add("t_lease_expires__after", parameterToString(*r.tLeaseExpiresAfter, ""))
	}
	if r.tLeaseExpiresBefore != nil {
		localVarQueryParams.Add("t_lease_expires__before", parameterToString(*r.tLeaseExpiresBefore, ""))
	}
	if r.tLeaseExpiresIsnull != nil {
		localVarQueryParams.Add("t_lease_expires__isnull", parameterToString(*r.tLeaseExpiresIsnull, ""))
	}
	if r.tQueuePositionUpdated != nil {
		localVarQueryParams.Add("t_queue_position_updated", parameterToString(*r.tQueuePositionUpdated, ""))
	}
	if r.tRequested != nil {
		localVarQueryParams.Add("t_requested", parameterToString(*r.tRequested, ""))
	}
	if r.tRequestedAfter != nil {
		localVarQueryParams.Add("t_requested__after", parameterToString(*r.tRequestedAfter, ""))
	}
	if r.tRequestedBefore != nil {
		localVarQueryParams.Add("t_requested__before", parameterToString(*r.tRequestedBefore, ""))
	}
	if r.tSatisfied != nil {
		localVarQueryParams.Add("t_satisfied", parameterToString(*r.tSatisfied, ""))
	}
	if r.tSatisfiedAfter != nil {
		localVarQueryParams.Add("t_satisfied__after", parameterToString(*r.tSatisfiedAfter, ""))
	}
	if r.tSatisfiedBefore != nil {
		localVarQueryParams.Add("t_satisfied__before", parameterToString(*r.tSatisfiedBefore, ""))
	}
	if r.tSatisfiedIsnull != nil {
		localVarQueryParams.Add("t_satisfied__isnull", parameterToString(*r.tSatisfiedIsnull, ""))
	}
	if r.useWatchdog != nil {
		localVarQueryParams.Add("use_watchdog", parameterToString(*r.useWatchdog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsActiveListRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	leaseDurationS *int32
	maxHistory *time.Time
	ordering *string
	owner *int32
	page *int32
	queuePosition *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	state *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tQueuePositionUpdated *time.Time
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsActiveListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsActiveListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsActiveListRequest) ADevices(aDevices []int32) ApiReservationsActiveListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsActiveListRequest) CancelExisting(cancelExisting bool) ApiReservationsActiveListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsActiveListRequest) Details(details string) ApiReservationsActiveListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsActiveListRequest) Device(device float32) ApiReservationsActiveListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsActiveListRequest) DeviceGroup(deviceGroup float32) ApiReservationsActiveListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsActiveListRequest) Id(id string) ApiReservationsActiveListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsActiveListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsActiveListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsActiveListRequest) InvertPriority(invertPriority bool) ApiReservationsActiveListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsActiveListRequest) Label(label float32) ApiReservationsActiveListRequest {
	r.label = &label
	return r
}

func (r ApiReservationsActiveListRequest) LeaseDurationS(leaseDurationS int32) ApiReservationsActiveListRequest {
	r.leaseDurationS = &leaseDurationS
	return r
}

// Filter out reservations that expired before the specified datetime. Defaults to 24 hours prior.
func (r ApiReservationsActiveListRequest) MaxHistory(maxHistory time.Time) ApiReservationsActiveListRequest {
	r.maxHistory = &maxHistory
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsActiveListRequest) Ordering(ordering string) ApiReservationsActiveListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsActiveListRequest) Owner(owner int32) ApiReservationsActiveListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsActiveListRequest) Page(page int32) ApiReservationsActiveListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsActiveListRequest) QueuePosition(queuePosition int32) ApiReservationsActiveListRequest {
	r.queuePosition = &queuePosition
	return r
}

func (r ApiReservationsActiveListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsActiveListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsActiveListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsActiveListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsActiveListRequest) RDevices(rDevices []int32) ApiReservationsActiveListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsActiveListRequest) Search(search string) ApiReservationsActiveListRequest {
	r.search = &search
	return r
}

// * &#x60;CRE_PEND&#x60; - create_pending * &#x60;QUE&#x60; - queued * &#x60;RES_PEND&#x60; - reservation_pending * &#x60;ACT&#x60; - active * &#x60;CAN_PEND&#x60; - cancel_pending * &#x60;REL_PEND&#x60; - release_pending * &#x60;FIN&#x60; - finished * &#x60;EXP_PEND&#x60; - expire_pending * &#x60;EXP&#x60; - expired * &#x60;FAIL&#x60; - failed
func (r ApiReservationsActiveListRequest) State(state string) ApiReservationsActiveListRequest {
	r.state = &state
	return r
}

// * &#x60;ACT&#x60; - Active * &#x60;FIN&#x60; - Finished * &#x60;QUE&#x60; - Queued * &#x60;EXP&#x60; - Expired * &#x60;&#x60; - Any
func (r ApiReservationsActiveListRequest) Status(status string) ApiReservationsActiveListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsActiveListRequest) TCompleted(tCompleted time.Time) ApiReservationsActiveListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsActiveListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsActiveListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsActiveListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsActiveListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsActiveListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsActiveListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsActiveListRequest) TQueuePositionUpdated(tQueuePositionUpdated time.Time) ApiReservationsActiveListRequest {
	r.tQueuePositionUpdated = &tQueuePositionUpdated
	return r
}

func (r ApiReservationsActiveListRequest) TRequested(tRequested time.Time) ApiReservationsActiveListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsActiveListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsActiveListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsActiveListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsActiveListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsActiveListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsActiveListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsActiveListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsActiveListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsActiveListRequest) UseWatchdog(useWatchdog bool) ApiReservationsActiveListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsActiveListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsActiveListExecute(r)
}

/*
ReservationsActiveList Method for ReservationsActiveList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsActiveListRequest
*/
func (a *ReservationsApiService) ReservationsActiveList(ctx context.Context) ApiReservationsActiveListRequest {
	return ApiReservationsActiveListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsApiService) ReservationsActiveListExecute(r ApiReservationsActiveListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsActiveList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/active/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_devices", parameterToString(t, "multi"))
		}
	}
	if r.cancelExisting != nil {
		localVarQueryParams.Add("cancel_existing", parameterToString(*r.cancelExisting, ""))
	}
	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.deviceGroup != nil {
		localVarQueryParams.Add("device_group", parameterToString(*r.deviceGroup, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.includeResourceData != nil {
		localVarQueryParams.Add("include_resource_data", parameterToString(*r.includeResourceData, ""))
	}
	if r.invertPriority != nil {
		localVarQueryParams.Add("invert_priority", parameterToString(*r.invertPriority, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.leaseDurationS != nil {
		localVarQueryParams.Add("lease_duration_s", parameterToString(*r.leaseDurationS, ""))
	}
	if r.maxHistory != nil {
		localVarQueryParams.Add("max_history", parameterToString(*r.maxHistory, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.queuePosition != nil {
		localVarQueryParams.Add("queue_position", parameterToString(*r.queuePosition, ""))
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_group_labels", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_group_labels", parameterToString(t, "multi"))
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_devices", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.tCompleted != nil {
		localVarQueryParams.Add("t_completed", parameterToString(*r.tCompleted, ""))
	}
	if r.tCompletedAfter != nil {
		localVarQueryParams.Add("t_completed__after", parameterToString(*r.tCompletedAfter, ""))
	}
	if r.tCompletedBefore != nil {
		localVarQueryParams.Add("t_completed__before", parameterToString(*r.tCompletedBefore, ""))
	}
	if r.tCompletedIsnull != nil {
		localVarQueryParams.Add("t_completed__isnull", parameterToString(*r.tCompletedIsnull, ""))
	}
	if r.tLeaseExpires != nil {
		localVarQueryParams.Add("t_lease_expires", parameterToString(*r.tLeaseExpires, ""))
	}
	if r.tLeaseExpiresAfter != nil {
		localVarQueryParams.Add("t_lease_expires__after", parameterToString(*r.tLeaseExpiresAfter, ""))
	}
	if r.tLeaseExpiresBefore != nil {
		localVarQueryParams.Add("t_lease_expires__before", parameterToString(*r.tLeaseExpiresBefore, ""))
	}
	if r.tLeaseExpiresIsnull != nil {
		localVarQueryParams.Add("t_lease_expires__isnull", parameterToString(*r.tLeaseExpiresIsnull, ""))
	}
	if r.tQueuePositionUpdated != nil {
		localVarQueryParams.Add("t_queue_position_updated", parameterToString(*r.tQueuePositionUpdated, ""))
	}
	if r.tRequested != nil {
		localVarQueryParams.Add("t_requested", parameterToString(*r.tRequested, ""))
	}
	if r.tRequestedAfter != nil {
		localVarQueryParams.Add("t_requested__after", parameterToString(*r.tRequestedAfter, ""))
	}
	if r.tRequestedBefore != nil {
		localVarQueryParams.Add("t_requested__before", parameterToString(*r.tRequestedBefore, ""))
	}
	if r.tSatisfied != nil {
		localVarQueryParams.Add("t_satisfied", parameterToString(*r.tSatisfied, ""))
	}
	if r.tSatisfiedAfter != nil {
		localVarQueryParams.Add("t_satisfied__after", parameterToString(*r.tSatisfiedAfter, ""))
	}
	if r.tSatisfiedBefore != nil {
		localVarQueryParams.Add("t_satisfied__before", parameterToString(*r.tSatisfiedBefore, ""))
	}
	if r.tSatisfiedIsnull != nil {
		localVarQueryParams.Add("t_satisfied__isnull", parameterToString(*r.tSatisfiedIsnull, ""))
	}
	if r.useWatchdog != nil {
		localVarQueryParams.Add("use_watchdog", parameterToString(*r.useWatchdog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsCancelUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
}

func (r ApiReservationsCancelUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsCancelUpdateExecute(r)
}

/*
ReservationsCancelUpdate Method for ReservationsCancelUpdate

Release the reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsCancelUpdateRequest
*/
func (a *ReservationsApiService) ReservationsCancelUpdate(ctx context.Context, id string) ApiReservationsCancelUpdateRequest {
	return ApiReservationsCancelUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsCancelUpdateExecute(r ApiReservationsCancelUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsCancelUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsCreateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	reservationRequest *ReservationRequest
}

func (r ApiReservationsCreateRequest) ReservationRequest(reservationRequest ReservationRequest) ApiReservationsCreateRequest {
	r.reservationRequest = &reservationRequest
	return r
}

func (r ApiReservationsCreateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsCreateExecute(r)
}

/*
ReservationsCreate Method for ReservationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsCreateRequest
*/
func (a *ReservationsApiService) ReservationsCreate(ctx context.Context) ApiReservationsCreateRequest {
	return ApiReservationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsCreateExecute(r ApiReservationsCreateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reservationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsExtendUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
	reservationExtensionRequest *ReservationExtensionRequest
}

func (r ApiReservationsExtendUpdateRequest) ReservationExtensionRequest(reservationExtensionRequest ReservationExtensionRequest) ApiReservationsExtendUpdateRequest {
	r.reservationExtensionRequest = &reservationExtensionRequest
	return r
}

func (r ApiReservationsExtendUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsExtendUpdateExecute(r)
}

/*
ReservationsExtendUpdate Method for ReservationsExtendUpdate

Extend an Active reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsExtendUpdateRequest
*/
func (a *ReservationsApiService) ReservationsExtendUpdate(ctx context.Context, id string) ApiReservationsExtendUpdateRequest {
	return ApiReservationsExtendUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsExtendUpdateExecute(r ApiReservationsExtendUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsExtendUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/extend/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reservationExtensionRequest == nil {
		return localVarReturnValue, nil, reportError("reservationExtensionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reservationExtensionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsListRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	aDeviceGroups *[]int32
	aDevices *[]int32
	cancelExisting *bool
	details *string
	device *float32
	deviceGroup *float32
	id *string
	includeResourceData *bool
	invertPriority *bool
	label *float32
	leaseDurationS *int32
	ordering *string
	owner *int32
	page *int32
	queuePosition *int32
	rDeviceGroupLabels *[]int32
	rDeviceGroups *[]int32
	rDevices *[]int32
	search *string
	state *string
	status *string
	tCompleted *time.Time
	tCompletedAfter *time.Time
	tCompletedBefore *time.Time
	tCompletedIsnull *bool
	tLeaseExpires *time.Time
	tLeaseExpiresAfter *time.Time
	tLeaseExpiresBefore *time.Time
	tLeaseExpiresIsnull *bool
	tQueuePositionUpdated *time.Time
	tRequested *time.Time
	tRequestedAfter *time.Time
	tRequestedBefore *time.Time
	tSatisfied *time.Time
	tSatisfiedAfter *time.Time
	tSatisfiedBefore *time.Time
	tSatisfiedIsnull *bool
	useWatchdog *bool
}

func (r ApiReservationsListRequest) ADeviceGroups(aDeviceGroups []int32) ApiReservationsListRequest {
	r.aDeviceGroups = &aDeviceGroups
	return r
}

func (r ApiReservationsListRequest) ADevices(aDevices []int32) ApiReservationsListRequest {
	r.aDevices = &aDevices
	return r
}

func (r ApiReservationsListRequest) CancelExisting(cancelExisting bool) ApiReservationsListRequest {
	r.cancelExisting = &cancelExisting
	return r
}

func (r ApiReservationsListRequest) Details(details string) ApiReservationsListRequest {
	r.details = &details
	return r
}

func (r ApiReservationsListRequest) Device(device float32) ApiReservationsListRequest {
	r.device = &device
	return r
}

func (r ApiReservationsListRequest) DeviceGroup(deviceGroup float32) ApiReservationsListRequest {
	r.deviceGroup = &deviceGroup
	return r
}

func (r ApiReservationsListRequest) Id(id string) ApiReservationsListRequest {
	r.id = &id
	return r
}

// Whether to include the detailed data for all resources related to the reservation.
func (r ApiReservationsListRequest) IncludeResourceData(includeResourceData bool) ApiReservationsListRequest {
	r.includeResourceData = &includeResourceData
	return r
}

func (r ApiReservationsListRequest) InvertPriority(invertPriority bool) ApiReservationsListRequest {
	r.invertPriority = &invertPriority
	return r
}

func (r ApiReservationsListRequest) Label(label float32) ApiReservationsListRequest {
	r.label = &label
	return r
}

func (r ApiReservationsListRequest) LeaseDurationS(leaseDurationS int32) ApiReservationsListRequest {
	r.leaseDurationS = &leaseDurationS
	return r
}

// Which field to use when ordering the results.
func (r ApiReservationsListRequest) Ordering(ordering string) ApiReservationsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiReservationsListRequest) Owner(owner int32) ApiReservationsListRequest {
	r.owner = &owner
	return r
}

// A page number within the paginated result set.
func (r ApiReservationsListRequest) Page(page int32) ApiReservationsListRequest {
	r.page = &page
	return r
}

func (r ApiReservationsListRequest) QueuePosition(queuePosition int32) ApiReservationsListRequest {
	r.queuePosition = &queuePosition
	return r
}

func (r ApiReservationsListRequest) RDeviceGroupLabels(rDeviceGroupLabels []int32) ApiReservationsListRequest {
	r.rDeviceGroupLabels = &rDeviceGroupLabels
	return r
}

func (r ApiReservationsListRequest) RDeviceGroups(rDeviceGroups []int32) ApiReservationsListRequest {
	r.rDeviceGroups = &rDeviceGroups
	return r
}

func (r ApiReservationsListRequest) RDevices(rDevices []int32) ApiReservationsListRequest {
	r.rDevices = &rDevices
	return r
}

// A search term.
func (r ApiReservationsListRequest) Search(search string) ApiReservationsListRequest {
	r.search = &search
	return r
}

// * &#x60;CRE_PEND&#x60; - create_pending * &#x60;QUE&#x60; - queued * &#x60;RES_PEND&#x60; - reservation_pending * &#x60;ACT&#x60; - active * &#x60;CAN_PEND&#x60; - cancel_pending * &#x60;REL_PEND&#x60; - release_pending * &#x60;FIN&#x60; - finished * &#x60;EXP_PEND&#x60; - expire_pending * &#x60;EXP&#x60; - expired * &#x60;FAIL&#x60; - failed
func (r ApiReservationsListRequest) State(state string) ApiReservationsListRequest {
	r.state = &state
	return r
}

// * &#x60;ACT&#x60; - Active * &#x60;FIN&#x60; - Finished * &#x60;QUE&#x60; - Queued * &#x60;EXP&#x60; - Expired * &#x60;&#x60; - Any
func (r ApiReservationsListRequest) Status(status string) ApiReservationsListRequest {
	r.status = &status
	return r
}

func (r ApiReservationsListRequest) TCompleted(tCompleted time.Time) ApiReservationsListRequest {
	r.tCompleted = &tCompleted
	return r
}

func (r ApiReservationsListRequest) TCompletedAfter(tCompletedAfter time.Time) ApiReservationsListRequest {
	r.tCompletedAfter = &tCompletedAfter
	return r
}

func (r ApiReservationsListRequest) TCompletedBefore(tCompletedBefore time.Time) ApiReservationsListRequest {
	r.tCompletedBefore = &tCompletedBefore
	return r
}

func (r ApiReservationsListRequest) TCompletedIsnull(tCompletedIsnull bool) ApiReservationsListRequest {
	r.tCompletedIsnull = &tCompletedIsnull
	return r
}

func (r ApiReservationsListRequest) TLeaseExpires(tLeaseExpires time.Time) ApiReservationsListRequest {
	r.tLeaseExpires = &tLeaseExpires
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresAfter(tLeaseExpiresAfter time.Time) ApiReservationsListRequest {
	r.tLeaseExpiresAfter = &tLeaseExpiresAfter
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresBefore(tLeaseExpiresBefore time.Time) ApiReservationsListRequest {
	r.tLeaseExpiresBefore = &tLeaseExpiresBefore
	return r
}

func (r ApiReservationsListRequest) TLeaseExpiresIsnull(tLeaseExpiresIsnull bool) ApiReservationsListRequest {
	r.tLeaseExpiresIsnull = &tLeaseExpiresIsnull
	return r
}

func (r ApiReservationsListRequest) TQueuePositionUpdated(tQueuePositionUpdated time.Time) ApiReservationsListRequest {
	r.tQueuePositionUpdated = &tQueuePositionUpdated
	return r
}

func (r ApiReservationsListRequest) TRequested(tRequested time.Time) ApiReservationsListRequest {
	r.tRequested = &tRequested
	return r
}

func (r ApiReservationsListRequest) TRequestedAfter(tRequestedAfter time.Time) ApiReservationsListRequest {
	r.tRequestedAfter = &tRequestedAfter
	return r
}

func (r ApiReservationsListRequest) TRequestedBefore(tRequestedBefore time.Time) ApiReservationsListRequest {
	r.tRequestedBefore = &tRequestedBefore
	return r
}

func (r ApiReservationsListRequest) TSatisfied(tSatisfied time.Time) ApiReservationsListRequest {
	r.tSatisfied = &tSatisfied
	return r
}

func (r ApiReservationsListRequest) TSatisfiedAfter(tSatisfiedAfter time.Time) ApiReservationsListRequest {
	r.tSatisfiedAfter = &tSatisfiedAfter
	return r
}

func (r ApiReservationsListRequest) TSatisfiedBefore(tSatisfiedBefore time.Time) ApiReservationsListRequest {
	r.tSatisfiedBefore = &tSatisfiedBefore
	return r
}

func (r ApiReservationsListRequest) TSatisfiedIsnull(tSatisfiedIsnull bool) ApiReservationsListRequest {
	r.tSatisfiedIsnull = &tSatisfiedIsnull
	return r
}

func (r ApiReservationsListRequest) UseWatchdog(useWatchdog bool) ApiReservationsListRequest {
	r.useWatchdog = &useWatchdog
	return r
}

func (r ApiReservationsListRequest) Execute() (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	return r.ApiService.ReservationsListExecute(r)
}

/*
ReservationsList Method for ReservationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReservationsListRequest
*/
func (a *ReservationsApiService) ReservationsList(ctx context.Context) ApiReservationsListRequest {
	return ApiReservationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedReservationSessionSerializerReadOnlyList
func (a *ReservationsApiService) ReservationsListExecute(r ApiReservationsListRequest) (*PaginatedReservationSessionSerializerReadOnlyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedReservationSessionSerializerReadOnlyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aDeviceGroups != nil {
		t := *r.aDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.aDevices != nil {
		t := *r.aDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("a_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("a_devices", parameterToString(t, "multi"))
		}
	}
	if r.cancelExisting != nil {
		localVarQueryParams.Add("cancel_existing", parameterToString(*r.cancelExisting, ""))
	}
	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	if r.device != nil {
		localVarQueryParams.Add("device", parameterToString(*r.device, ""))
	}
	if r.deviceGroup != nil {
		localVarQueryParams.Add("device_group", parameterToString(*r.deviceGroup, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.includeResourceData != nil {
		localVarQueryParams.Add("include_resource_data", parameterToString(*r.includeResourceData, ""))
	}
	if r.invertPriority != nil {
		localVarQueryParams.Add("invert_priority", parameterToString(*r.invertPriority, ""))
	}
	if r.label != nil {
		localVarQueryParams.Add("label", parameterToString(*r.label, ""))
	}
	if r.leaseDurationS != nil {
		localVarQueryParams.Add("lease_duration_s", parameterToString(*r.leaseDurationS, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.owner != nil {
		localVarQueryParams.Add("owner", parameterToString(*r.owner, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.queuePosition != nil {
		localVarQueryParams.Add("queue_position", parameterToString(*r.queuePosition, ""))
	}
	if r.rDeviceGroupLabels != nil {
		t := *r.rDeviceGroupLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_group_labels", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_group_labels", parameterToString(t, "multi"))
		}
	}
	if r.rDeviceGroups != nil {
		t := *r.rDeviceGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_device_groups", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_device_groups", parameterToString(t, "multi"))
		}
	}
	if r.rDevices != nil {
		t := *r.rDevices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("r_devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("r_devices", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.tCompleted != nil {
		localVarQueryParams.Add("t_completed", parameterToString(*r.tCompleted, ""))
	}
	if r.tCompletedAfter != nil {
		localVarQueryParams.Add("t_completed__after", parameterToString(*r.tCompletedAfter, ""))
	}
	if r.tCompletedBefore != nil {
		localVarQueryParams.Add("t_completed__before", parameterToString(*r.tCompletedBefore, ""))
	}
	if r.tCompletedIsnull != nil {
		localVarQueryParams.Add("t_completed__isnull", parameterToString(*r.tCompletedIsnull, ""))
	}
	if r.tLeaseExpires != nil {
		localVarQueryParams.Add("t_lease_expires", parameterToString(*r.tLeaseExpires, ""))
	}
	if r.tLeaseExpiresAfter != nil {
		localVarQueryParams.Add("t_lease_expires__after", parameterToString(*r.tLeaseExpiresAfter, ""))
	}
	if r.tLeaseExpiresBefore != nil {
		localVarQueryParams.Add("t_lease_expires__before", parameterToString(*r.tLeaseExpiresBefore, ""))
	}
	if r.tLeaseExpiresIsnull != nil {
		localVarQueryParams.Add("t_lease_expires__isnull", parameterToString(*r.tLeaseExpiresIsnull, ""))
	}
	if r.tQueuePositionUpdated != nil {
		localVarQueryParams.Add("t_queue_position_updated", parameterToString(*r.tQueuePositionUpdated, ""))
	}
	if r.tRequested != nil {
		localVarQueryParams.Add("t_requested", parameterToString(*r.tRequested, ""))
	}
	if r.tRequestedAfter != nil {
		localVarQueryParams.Add("t_requested__after", parameterToString(*r.tRequestedAfter, ""))
	}
	if r.tRequestedBefore != nil {
		localVarQueryParams.Add("t_requested__before", parameterToString(*r.tRequestedBefore, ""))
	}
	if r.tSatisfied != nil {
		localVarQueryParams.Add("t_satisfied", parameterToString(*r.tSatisfied, ""))
	}
	if r.tSatisfiedAfter != nil {
		localVarQueryParams.Add("t_satisfied__after", parameterToString(*r.tSatisfiedAfter, ""))
	}
	if r.tSatisfiedBefore != nil {
		localVarQueryParams.Add("t_satisfied__before", parameterToString(*r.tSatisfiedBefore, ""))
	}
	if r.tSatisfiedIsnull != nil {
		localVarQueryParams.Add("t_satisfied__isnull", parameterToString(*r.tSatisfiedIsnull, ""))
	}
	if r.useWatchdog != nil {
		localVarQueryParams.Add("use_watchdog", parameterToString(*r.useWatchdog, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsMetadataPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
	requestBody *map[string]interface{}
}

func (r ApiReservationsMetadataPartialUpdateRequest) RequestBody(requestBody map[string]interface{}) ApiReservationsMetadataPartialUpdateRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiReservationsMetadataPartialUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsMetadataPartialUpdateExecute(r)
}

/*
ReservationsMetadataPartialUpdate Method for ReservationsMetadataPartialUpdate

Update the reservation metadata. Use PUT to replace the existing data
entirely and PATCH to update without deleting existing values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsMetadataPartialUpdateRequest
*/
func (a *ReservationsApiService) ReservationsMetadataPartialUpdate(ctx context.Context, id string) ApiReservationsMetadataPartialUpdateRequest {
	return ApiReservationsMetadataPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsMetadataPartialUpdateExecute(r ApiReservationsMetadataPartialUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsMetadataPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsMetadataUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
	requestBody *map[string]interface{}
}

func (r ApiReservationsMetadataUpdateRequest) RequestBody(requestBody map[string]interface{}) ApiReservationsMetadataUpdateRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiReservationsMetadataUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsMetadataUpdateExecute(r)
}

/*
ReservationsMetadataUpdate Method for ReservationsMetadataUpdate

Update the reservation metadata. Use PUT to replace the existing data
entirely and PATCH to update without deleting existing values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsMetadataUpdateRequest
*/
func (a *ReservationsApiService) ReservationsMetadataUpdate(ctx context.Context, id string) ApiReservationsMetadataUpdateRequest {
	return ApiReservationsMetadataUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsMetadataUpdateExecute(r ApiReservationsMetadataUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsMetadataUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsReleaseUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
}

func (r ApiReservationsReleaseUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsReleaseUpdateExecute(r)
}

/*
ReservationsReleaseUpdate Method for ReservationsReleaseUpdate

Release the reservation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsReleaseUpdateRequest
*/
func (a *ReservationsApiService) ReservationsReleaseUpdate(ctx context.Context, id string) ApiReservationsReleaseUpdateRequest {
	return ApiReservationsReleaseUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsReleaseUpdateExecute(r ApiReservationsReleaseUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsReleaseUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/release/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsRetrieveRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
}

func (r ApiReservationsRetrieveRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsRetrieveExecute(r)
}

/*
ReservationsRetrieve Method for ReservationsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsRetrieveRequest
*/
func (a *ReservationsApiService) ReservationsRetrieve(ctx context.Context, id string) ApiReservationsRetrieveRequest {
	return ApiReservationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsRetrieveExecute(r ApiReservationsRetrieveRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReservationsUpdateRequest struct {
	ctx context.Context
	ApiService *ReservationsApiService
	id string
}

func (r ApiReservationsUpdateRequest) Execute() (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	return r.ApiService.ReservationsUpdateExecute(r)
}

/*
ReservationsUpdate Method for ReservationsUpdate

Check queue status or renew lease if reservation is ongoing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this reservation session.
 @return ApiReservationsUpdateRequest
*/
func (a *ReservationsApiService) ReservationsUpdate(ctx context.Context, id string) ApiReservationsUpdateRequest {
	return ApiReservationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReservationSessionSerializerReadOnly
func (a *ReservationsApiService) ReservationsUpdateExecute(r ApiReservationsUpdateRequest) (*ReservationSessionSerializerReadOnly, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationSessionSerializerReadOnly
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationsApiService.ReservationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/reservations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
