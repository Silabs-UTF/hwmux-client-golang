/*
HW Mux Reservation System

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.32.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hwmux

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// GroupsApiService GroupsApi service
type GroupsApiService service

type ApiGroupsAvailableListRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	devices *[]int32
	enableAhs *bool
	enableAhsActions *bool
	enableAhsCas *bool
	idIn *[]string
	name *string
	ordering *string
	page *int32
	room *string
	search *string
	site *string
	source *string
}

func (r ApiGroupsAvailableListRequest) Devices(devices []int32) ApiGroupsAvailableListRequest {
	r.devices = &devices
	return r
}

func (r ApiGroupsAvailableListRequest) EnableAhs(enableAhs bool) ApiGroupsAvailableListRequest {
	r.enableAhs = &enableAhs
	return r
}

func (r ApiGroupsAvailableListRequest) EnableAhsActions(enableAhsActions bool) ApiGroupsAvailableListRequest {
	r.enableAhsActions = &enableAhsActions
	return r
}

func (r ApiGroupsAvailableListRequest) EnableAhsCas(enableAhsCas bool) ApiGroupsAvailableListRequest {
	r.enableAhsCas = &enableAhsCas
	return r
}

// Multiple values may be separated by commas.
func (r ApiGroupsAvailableListRequest) IdIn(idIn []string) ApiGroupsAvailableListRequest {
	r.idIn = &idIn
	return r
}

func (r ApiGroupsAvailableListRequest) Name(name string) ApiGroupsAvailableListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiGroupsAvailableListRequest) Ordering(ordering string) ApiGroupsAvailableListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiGroupsAvailableListRequest) Page(page int32) ApiGroupsAvailableListRequest {
	r.page = &page
	return r
}

func (r ApiGroupsAvailableListRequest) Room(room string) ApiGroupsAvailableListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiGroupsAvailableListRequest) Search(search string) ApiGroupsAvailableListRequest {
	r.search = &search
	return r
}

func (r ApiGroupsAvailableListRequest) Site(site string) ApiGroupsAvailableListRequest {
	r.site = &site
	return r
}

// * &#x60;TERRAFORM&#x60; - Terraform * &#x60;XML&#x60; - XML * &#x60;UI&#x60; - UI * &#x60;OTHER&#x60; - Other
func (r ApiGroupsAvailableListRequest) Source(source string) ApiGroupsAvailableListRequest {
	r.source = &source
	return r
}

func (r ApiGroupsAvailableListRequest) Execute() (*PaginatedDeviceGroupList, *http.Response, error) {
	return r.ApiService.GroupsAvailableListExecute(r)
}

/*
GroupsAvailableList Method for GroupsAvailableList

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsAvailableListRequest
*/
func (a *GroupsApiService) GroupsAvailableList(ctx context.Context) ApiGroupsAvailableListRequest {
	return ApiGroupsAvailableListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceGroupList
func (a *GroupsApiService) GroupsAvailableListExecute(r ApiGroupsAvailableListRequest) (*PaginatedDeviceGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsAvailableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/available/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("devices", parameterToString(t, "multi"))
		}
	}
	if r.enableAhs != nil {
		localVarQueryParams.Add("enable_ahs", parameterToString(*r.enableAhs, ""))
	}
	if r.enableAhsActions != nil {
		localVarQueryParams.Add("enable_ahs_actions", parameterToString(*r.enableAhsActions, ""))
	}
	if r.enableAhsCas != nil {
		localVarQueryParams.Add("enable_ahs_cas", parameterToString(*r.enableAhsCas, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.source != nil {
		localVarQueryParams.Add("source", parameterToString(*r.source, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	deviceGroupSerializerWithDevicePk *DeviceGroupSerializerWithDevicePk
}

func (r ApiGroupsCreateRequest) DeviceGroupSerializerWithDevicePk(deviceGroupSerializerWithDevicePk DeviceGroupSerializerWithDevicePk) ApiGroupsCreateRequest {
	r.deviceGroupSerializerWithDevicePk = &deviceGroupSerializerWithDevicePk
	return r
}

func (r ApiGroupsCreateRequest) Execute() (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	return r.ApiService.GroupsCreateExecute(r)
}

/*
GroupsCreate Method for GroupsCreate

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsCreateRequest
*/
func (a *GroupsApiService) GroupsCreate(ctx context.Context) ApiGroupsCreateRequest {
	return ApiGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceGroupSerializerWithDevicePk
func (a *GroupsApiService) GroupsCreateExecute(r ApiGroupsCreateRequest) (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroupSerializerWithDevicePk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceGroupSerializerWithDevicePk == nil {
		return localVarReturnValue, nil, reportError("deviceGroupSerializerWithDevicePk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceGroupSerializerWithDevicePk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsCreateWithDevicesCreateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	nestedDeviceGroup *NestedDeviceGroup
}

func (r ApiGroupsCreateWithDevicesCreateRequest) NestedDeviceGroup(nestedDeviceGroup NestedDeviceGroup) ApiGroupsCreateWithDevicesCreateRequest {
	r.nestedDeviceGroup = &nestedDeviceGroup
	return r
}

func (r ApiGroupsCreateWithDevicesCreateRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsCreateWithDevicesCreateExecute(r)
}

/*
GroupsCreateWithDevicesCreate Method for GroupsCreateWithDevicesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsCreateWithDevicesCreateRequest
*/
func (a *GroupsApiService) GroupsCreateWithDevicesCreate(ctx context.Context) ApiGroupsCreateWithDevicesCreateRequest {
	return ApiGroupsCreateWithDevicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsCreateWithDevicesCreateExecute(r ApiGroupsCreateWithDevicesCreateRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsCreateWithDevicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/create-with-devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedDeviceGroup == nil {
		return localVarReturnValue, nil, reportError("nestedDeviceGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedDeviceGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
}

func (r ApiGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.GroupsDestroyExecute(r)
}

/*
GroupsDestroy Method for GroupsDestroy

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsDestroyRequest
*/
func (a *GroupsApiService) GroupsDestroy(ctx context.Context, id int32) ApiGroupsDestroyRequest {
	return ApiGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *GroupsApiService) GroupsDestroyExecute(r ApiGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGroupsListRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	devices *[]int32
	enableAhs *bool
	enableAhsActions *bool
	enableAhsCas *bool
	forceMv *string
	idIn *[]string
	includePermissionGroups *bool
	name *string
	ordering *string
	page *int32
	room *string
	search *string
	site *string
	source *string
}

func (r ApiGroupsListRequest) Devices(devices []int32) ApiGroupsListRequest {
	r.devices = &devices
	return r
}

func (r ApiGroupsListRequest) EnableAhs(enableAhs bool) ApiGroupsListRequest {
	r.enableAhs = &enableAhs
	return r
}

func (r ApiGroupsListRequest) EnableAhsActions(enableAhsActions bool) ApiGroupsListRequest {
	r.enableAhsActions = &enableAhsActions
	return r
}

func (r ApiGroupsListRequest) EnableAhsCas(enableAhsCas bool) ApiGroupsListRequest {
	r.enableAhsCas = &enableAhsCas
	return r
}

// Specifies the behavior of the force_mv attribute. DEFAULT : Default condition which retrieve data from the Materialized view unless ax exception occurs where we fall back to postgres. ON : Force the data to be retrieved from the Materialized view. OFF : Force the data to be retrieved from the Postgres database
func (r ApiGroupsListRequest) ForceMv(forceMv string) ApiGroupsListRequest {
	r.forceMv = &forceMv
	return r
}

// Multiple values may be separated by commas.
func (r ApiGroupsListRequest) IdIn(idIn []string) ApiGroupsListRequest {
	r.idIn = &idIn
	return r
}

// If set to true, the permission groups associated with this resource will be included in the response. Defaults to false.
func (r ApiGroupsListRequest) IncludePermissionGroups(includePermissionGroups bool) ApiGroupsListRequest {
	r.includePermissionGroups = &includePermissionGroups
	return r
}

func (r ApiGroupsListRequest) Name(name string) ApiGroupsListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiGroupsListRequest) Ordering(ordering string) ApiGroupsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiGroupsListRequest) Page(page int32) ApiGroupsListRequest {
	r.page = &page
	return r
}

func (r ApiGroupsListRequest) Room(room string) ApiGroupsListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiGroupsListRequest) Search(search string) ApiGroupsListRequest {
	r.search = &search
	return r
}

func (r ApiGroupsListRequest) Site(site string) ApiGroupsListRequest {
	r.site = &site
	return r
}

// * &#x60;TERRAFORM&#x60; - Terraform * &#x60;XML&#x60; - XML * &#x60;UI&#x60; - UI * &#x60;OTHER&#x60; - Other
func (r ApiGroupsListRequest) Source(source string) ApiGroupsListRequest {
	r.source = &source
	return r
}

func (r ApiGroupsListRequest) Execute() (*PaginatedDeviceGroupList, *http.Response, error) {
	return r.ApiService.GroupsListExecute(r)
}

/*
GroupsList Method for GroupsList

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsListRequest
*/
func (a *GroupsApiService) GroupsList(ctx context.Context) ApiGroupsListRequest {
	return ApiGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceGroupList
func (a *GroupsApiService) GroupsListExecute(r ApiGroupsListRequest) (*PaginatedDeviceGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("devices", parameterToString(t, "multi"))
		}
	}
	if r.enableAhs != nil {
		localVarQueryParams.Add("enable_ahs", parameterToString(*r.enableAhs, ""))
	}
	if r.enableAhsActions != nil {
		localVarQueryParams.Add("enable_ahs_actions", parameterToString(*r.enableAhsActions, ""))
	}
	if r.enableAhsCas != nil {
		localVarQueryParams.Add("enable_ahs_cas", parameterToString(*r.enableAhsCas, ""))
	}
	if r.forceMv != nil {
		localVarQueryParams.Add("force_mv", parameterToString(*r.forceMv, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.includePermissionGroups != nil {
		localVarQueryParams.Add("include_permission_groups", parameterToString(*r.includePermissionGroups, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.source != nil {
		localVarQueryParams.Add("source", parameterToString(*r.source, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsLocationRetrieveRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	deviceGroupPk string
}

func (r ApiGroupsLocationRetrieveRequest) Execute() (*GroupLocation, *http.Response, error) {
	return r.ApiService.GroupsLocationRetrieveExecute(r)
}

/*
GroupsLocationRetrieve Method for GroupsLocationRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceGroupPk
 @return ApiGroupsLocationRetrieveRequest
*/
func (a *GroupsApiService) GroupsLocationRetrieve(ctx context.Context, deviceGroupPk string) ApiGroupsLocationRetrieveRequest {
	return ApiGroupsLocationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		deviceGroupPk: deviceGroupPk,
	}
}

// Execute executes the request
//  @return GroupLocation
func (a *GroupsApiService) GroupsLocationRetrieveExecute(r ApiGroupsLocationRetrieveRequest) (*GroupLocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupLocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsLocationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{device_group_pk}/location/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_group_pk"+"}", url.PathEscape(parameterToString(r.deviceGroupPk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsMyListRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	devices *[]int32
	enableAhs *bool
	enableAhsActions *bool
	enableAhsCas *bool
	idIn *[]string
	name *string
	ordering *string
	page *int32
	room *string
	search *string
	site *string
	source *string
}

func (r ApiGroupsMyListRequest) Devices(devices []int32) ApiGroupsMyListRequest {
	r.devices = &devices
	return r
}

func (r ApiGroupsMyListRequest) EnableAhs(enableAhs bool) ApiGroupsMyListRequest {
	r.enableAhs = &enableAhs
	return r
}

func (r ApiGroupsMyListRequest) EnableAhsActions(enableAhsActions bool) ApiGroupsMyListRequest {
	r.enableAhsActions = &enableAhsActions
	return r
}

func (r ApiGroupsMyListRequest) EnableAhsCas(enableAhsCas bool) ApiGroupsMyListRequest {
	r.enableAhsCas = &enableAhsCas
	return r
}

// Multiple values may be separated by commas.
func (r ApiGroupsMyListRequest) IdIn(idIn []string) ApiGroupsMyListRequest {
	r.idIn = &idIn
	return r
}

func (r ApiGroupsMyListRequest) Name(name string) ApiGroupsMyListRequest {
	r.name = &name
	return r
}

// Which field to use when ordering the results.
func (r ApiGroupsMyListRequest) Ordering(ordering string) ApiGroupsMyListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiGroupsMyListRequest) Page(page int32) ApiGroupsMyListRequest {
	r.page = &page
	return r
}

func (r ApiGroupsMyListRequest) Room(room string) ApiGroupsMyListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiGroupsMyListRequest) Search(search string) ApiGroupsMyListRequest {
	r.search = &search
	return r
}

func (r ApiGroupsMyListRequest) Site(site string) ApiGroupsMyListRequest {
	r.site = &site
	return r
}

// * &#x60;TERRAFORM&#x60; - Terraform * &#x60;XML&#x60; - XML * &#x60;UI&#x60; - UI * &#x60;OTHER&#x60; - Other
func (r ApiGroupsMyListRequest) Source(source string) ApiGroupsMyListRequest {
	r.source = &source
	return r
}

func (r ApiGroupsMyListRequest) Execute() (*PaginatedDeviceGroupList, *http.Response, error) {
	return r.ApiService.GroupsMyListExecute(r)
}

/*
GroupsMyList Method for GroupsMyList

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsMyListRequest
*/
func (a *GroupsApiService) GroupsMyList(ctx context.Context) ApiGroupsMyListRequest {
	return ApiGroupsMyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceGroupList
func (a *GroupsApiService) GroupsMyListExecute(r ApiGroupsMyListRequest) (*PaginatedDeviceGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsMyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/my/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.devices != nil {
		t := *r.devices
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("devices", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("devices", parameterToString(t, "multi"))
		}
	}
	if r.enableAhs != nil {
		localVarQueryParams.Add("enable_ahs", parameterToString(*r.enableAhs, ""))
	}
	if r.enableAhsActions != nil {
		localVarQueryParams.Add("enable_ahs_actions", parameterToString(*r.enableAhsActions, ""))
	}
	if r.enableAhsCas != nil {
		localVarQueryParams.Add("enable_ahs_cas", parameterToString(*r.enableAhsCas, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.source != nil {
		localVarQueryParams.Add("source", parameterToString(*r.source, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	patchedDeviceGroupSerializerWithDevicePk *PatchedDeviceGroupSerializerWithDevicePk
}

func (r ApiGroupsPartialUpdateRequest) PatchedDeviceGroupSerializerWithDevicePk(patchedDeviceGroupSerializerWithDevicePk PatchedDeviceGroupSerializerWithDevicePk) ApiGroupsPartialUpdateRequest {
	r.patchedDeviceGroupSerializerWithDevicePk = &patchedDeviceGroupSerializerWithDevicePk
	return r
}

func (r ApiGroupsPartialUpdateRequest) Execute() (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	return r.ApiService.GroupsPartialUpdateExecute(r)
}

/*
GroupsPartialUpdate Method for GroupsPartialUpdate

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsPartialUpdateRequest
*/
func (a *GroupsApiService) GroupsPartialUpdate(ctx context.Context, id int32) ApiGroupsPartialUpdateRequest {
	return ApiGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceGroupSerializerWithDevicePk
func (a *GroupsApiService) GroupsPartialUpdateExecute(r ApiGroupsPartialUpdateRequest) (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroupSerializerWithDevicePk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDeviceGroupSerializerWithDevicePk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPermissionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	patchedObjectPermissions *PatchedObjectPermissions
}

func (r ApiGroupsPermissionsPartialUpdateRequest) PatchedObjectPermissions(patchedObjectPermissions PatchedObjectPermissions) ApiGroupsPermissionsPartialUpdateRequest {
	r.patchedObjectPermissions = &patchedObjectPermissions
	return r
}

func (r ApiGroupsPermissionsPartialUpdateRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.GroupsPermissionsPartialUpdateExecute(r)
}

/*
GroupsPermissionsPartialUpdate Method for GroupsPermissionsPartialUpdate

Partially update the object-level permissions for this resource.
Can omit top-level fields to leave unchanged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsPermissionsPartialUpdateRequest
*/
func (a *GroupsApiService) GroupsPermissionsPartialUpdate(ctx context.Context, id int32) ApiGroupsPermissionsPartialUpdateRequest {
	return ApiGroupsPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *GroupsApiService) GroupsPermissionsPartialUpdateExecute(r ApiGroupsPermissionsPartialUpdateRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedObjectPermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPermissionsRetrieveRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
}

func (r ApiGroupsPermissionsRetrieveRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.GroupsPermissionsRetrieveExecute(r)
}

/*
GroupsPermissionsRetrieve Method for GroupsPermissionsRetrieve

Get the object-level permissions for this resource. Will return
user permissions and user group permissions separately. User permissions
 will not include those derived from user group membership.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsPermissionsRetrieveRequest
*/
func (a *GroupsApiService) GroupsPermissionsRetrieve(ctx context.Context, id int32) ApiGroupsPermissionsRetrieveRequest {
	return ApiGroupsPermissionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *GroupsApiService) GroupsPermissionsRetrieveExecute(r ApiGroupsPermissionsRetrieveRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsPermissionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsPermissionsUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	objectPermissions *ObjectPermissions
}

func (r ApiGroupsPermissionsUpdateRequest) ObjectPermissions(objectPermissions ObjectPermissions) ApiGroupsPermissionsUpdateRequest {
	r.objectPermissions = &objectPermissions
	return r
}

func (r ApiGroupsPermissionsUpdateRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.GroupsPermissionsUpdateExecute(r)
}

/*
GroupsPermissionsUpdate Method for GroupsPermissionsUpdate

Update the object-level permissions for this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsPermissionsUpdateRequest
*/
func (a *GroupsApiService) GroupsPermissionsUpdate(ctx context.Context, id int32) ApiGroupsPermissionsUpdateRequest {
	return ApiGroupsPermissionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *GroupsApiService) GroupsPermissionsUpdateExecute(r ApiGroupsPermissionsUpdateRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissions == nil {
		return localVarReturnValue, nil, reportError("objectPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsReleaseByNameUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupName string
}

func (r ApiGroupsReleaseByNameUpdateRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsReleaseByNameUpdateExecute(r)
}

/*
GroupsReleaseByNameUpdate Method for GroupsReleaseByNameUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiGroupsReleaseByNameUpdateRequest
*/
func (a *GroupsApiService) GroupsReleaseByNameUpdate(ctx context.Context, groupName string) ApiGroupsReleaseByNameUpdateRequest {
	return ApiGroupsReleaseByNameUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsReleaseByNameUpdateExecute(r ApiGroupsReleaseByNameUpdateRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsReleaseByNameUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{group_name}/release_by_name/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsReleaseUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
}

func (r ApiGroupsReleaseUpdateRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsReleaseUpdateExecute(r)
}

/*
GroupsReleaseUpdate Method for GroupsReleaseUpdate

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsReleaseUpdateRequest
*/
func (a *GroupsApiService) GroupsReleaseUpdate(ctx context.Context, id int32) ApiGroupsReleaseUpdateRequest {
	return ApiGroupsReleaseUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsReleaseUpdateExecute(r ApiGroupsReleaseUpdateRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsReleaseUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/release/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsReserveByNameUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	groupName string
	details *string
}

// Additional information such as the jenkins job URL
func (r ApiGroupsReserveByNameUpdateRequest) Details(details string) ApiGroupsReserveByNameUpdateRequest {
	r.details = &details
	return r
}

func (r ApiGroupsReserveByNameUpdateRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsReserveByNameUpdateExecute(r)
}

/*
GroupsReserveByNameUpdate Method for GroupsReserveByNameUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiGroupsReserveByNameUpdateRequest
*/
func (a *GroupsApiService) GroupsReserveByNameUpdate(ctx context.Context, groupName string) ApiGroupsReserveByNameUpdateRequest {
	return ApiGroupsReserveByNameUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsReserveByNameUpdateExecute(r ApiGroupsReserveByNameUpdateRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsReserveByNameUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{group_name}/reserve_by_name/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsReserveUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	details *string
}

// Additional information such as the jenkins job URL
func (r ApiGroupsReserveUpdateRequest) Details(details string) ApiGroupsReserveUpdateRequest {
	r.details = &details
	return r
}

func (r ApiGroupsReserveUpdateRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsReserveUpdateExecute(r)
}

/*
GroupsReserveUpdate Method for GroupsReserveUpdate

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsReserveUpdateRequest
*/
func (a *GroupsApiService) GroupsReserveUpdate(ctx context.Context, id int32) ApiGroupsReserveUpdateRequest {
	return ApiGroupsReserveUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsReserveUpdateExecute(r ApiGroupsReserveUpdateRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsReserveUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/reserve/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	includePermissionGroups *bool
}

// If set to true, the permission groups associated with this resource will be included in the response. Defaults to false.
func (r ApiGroupsRetrieveRequest) IncludePermissionGroups(includePermissionGroups bool) ApiGroupsRetrieveRequest {
	r.includePermissionGroups = &includePermissionGroups
	return r
}

func (r ApiGroupsRetrieveRequest) Execute() (*DeviceGroup, *http.Response, error) {
	return r.ApiService.GroupsRetrieveExecute(r)
}

/*
GroupsRetrieve Method for GroupsRetrieve

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsRetrieveRequest
*/
func (a *GroupsApiService) GroupsRetrieve(ctx context.Context, id int32) ApiGroupsRetrieveRequest {
	return ApiGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceGroup
func (a *GroupsApiService) GroupsRetrieveExecute(r ApiGroupsRetrieveRequest) (*DeviceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includePermissionGroups != nil {
		localVarQueryParams.Add("include_permission_groups", parameterToString(*r.includePermissionGroups, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsStatusCreateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	resourceStatusRequest *ResourceStatusRequest
}

func (r ApiGroupsStatusCreateRequest) ResourceStatusRequest(resourceStatusRequest ResourceStatusRequest) ApiGroupsStatusCreateRequest {
	r.resourceStatusRequest = &resourceStatusRequest
	return r
}

func (r ApiGroupsStatusCreateRequest) Execute() (*ResourceStatusRequest, *http.Response, error) {
	return r.ApiService.GroupsStatusCreateExecute(r)
}

/*
GroupsStatusCreate Method for GroupsStatusCreate

Modify the device status.
A comment is required unless the new status is ACTIVE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsStatusCreateRequest
*/
func (a *GroupsApiService) GroupsStatusCreate(ctx context.Context, id int32) ApiGroupsStatusCreateRequest {
	return ApiGroupsStatusCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceStatusRequest
func (a *GroupsApiService) GroupsStatusCreateExecute(r ApiGroupsStatusCreateRequest) (*ResourceStatusRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceStatusRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsStatusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/status/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourceStatusRequest == nil {
		return localVarReturnValue, nil, reportError("resourceStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *GroupsApiService
	id int32
	deviceGroupSerializerWithDevicePk *DeviceGroupSerializerWithDevicePk
}

func (r ApiGroupsUpdateRequest) DeviceGroupSerializerWithDevicePk(deviceGroupSerializerWithDevicePk DeviceGroupSerializerWithDevicePk) ApiGroupsUpdateRequest {
	r.deviceGroupSerializerWithDevicePk = &deviceGroupSerializerWithDevicePk
	return r
}

func (r ApiGroupsUpdateRequest) Execute() (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	return r.ApiService.GroupsUpdateExecute(r)
}

/*
GroupsUpdate Method for GroupsUpdate

Viewset for DeviceGroup model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device group.
 @return ApiGroupsUpdateRequest
*/
func (a *GroupsApiService) GroupsUpdate(ctx context.Context, id int32) ApiGroupsUpdateRequest {
	return ApiGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceGroupSerializerWithDevicePk
func (a *GroupsApiService) GroupsUpdateExecute(r ApiGroupsUpdateRequest) (*DeviceGroupSerializerWithDevicePk, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceGroupSerializerWithDevicePk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceGroupSerializerWithDevicePk == nil {
		return localVarReturnValue, nil, reportError("deviceGroupSerializerWithDevicePk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deviceGroupSerializerWithDevicePk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
