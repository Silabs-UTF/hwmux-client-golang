/*
HW Mux Reservation System

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.19.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hwmux

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// DevicesApiService DevicesApi service
type DevicesApiService service

type ApiDevicesCreateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	writeOnlyDevice *WriteOnlyDevice
}

func (r ApiDevicesCreateRequest) WriteOnlyDevice(writeOnlyDevice WriteOnlyDevice) ApiDevicesCreateRequest {
	r.writeOnlyDevice = &writeOnlyDevice
	return r
}

func (r ApiDevicesCreateRequest) Execute() (*WriteOnlyDevice, *http.Response, error) {
	return r.ApiService.DevicesCreateExecute(r)
}

/*
DevicesCreate Method for DevicesCreate

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDevicesCreateRequest
*/
func (a *DevicesApiService) DevicesCreate(ctx context.Context) ApiDevicesCreateRequest {
	return ApiDevicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WriteOnlyDevice
func (a *DevicesApiService) DevicesCreateExecute(r ApiDevicesCreateRequest) (*WriteOnlyDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WriteOnlyDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writeOnlyDevice == nil {
		return localVarReturnValue, nil, reportError("writeOnlyDevice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writeOnlyDevice
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesDestroyRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
}

func (r ApiDevicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DevicesDestroyExecute(r)
}

/*
DevicesDestroy Method for DevicesDestroy

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesDestroyRequest
*/
func (a *DevicesApiService) DevicesDestroy(ctx context.Context, id int32) ApiDevicesDestroyRequest {
	return ApiDevicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DevicesApiService) DevicesDestroyExecute(r ApiDevicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDevicesListRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	dateCreated *time.Time
	idIn *[]string
	isWstk *bool
	lastUpdate *time.Time
	online *bool
	ordering *string
	page *int32
	part *string
	partFamily *string
	room *string
	search *string
	site *string
	snOrName *string
	snOrNameIsnull *bool
	status *string
	uri *string
	uriIsnull *bool
	wstkPart *string
}

func (r ApiDevicesListRequest) DateCreated(dateCreated time.Time) ApiDevicesListRequest {
	r.dateCreated = &dateCreated
	return r
}

// Multiple values may be separated by commas.
func (r ApiDevicesListRequest) IdIn(idIn []string) ApiDevicesListRequest {
	r.idIn = &idIn
	return r
}

func (r ApiDevicesListRequest) IsWstk(isWstk bool) ApiDevicesListRequest {
	r.isWstk = &isWstk
	return r
}

func (r ApiDevicesListRequest) LastUpdate(lastUpdate time.Time) ApiDevicesListRequest {
	r.lastUpdate = &lastUpdate
	return r
}

func (r ApiDevicesListRequest) Online(online bool) ApiDevicesListRequest {
	r.online = &online
	return r
}

// Which field to use when ordering the results.
func (r ApiDevicesListRequest) Ordering(ordering string) ApiDevicesListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiDevicesListRequest) Page(page int32) ApiDevicesListRequest {
	r.page = &page
	return r
}

func (r ApiDevicesListRequest) Part(part string) ApiDevicesListRequest {
	r.part = &part
	return r
}

func (r ApiDevicesListRequest) PartFamily(partFamily string) ApiDevicesListRequest {
	r.partFamily = &partFamily
	return r
}

func (r ApiDevicesListRequest) Room(room string) ApiDevicesListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiDevicesListRequest) Search(search string) ApiDevicesListRequest {
	r.search = &search
	return r
}

func (r ApiDevicesListRequest) Site(site string) ApiDevicesListRequest {
	r.site = &site
	return r
}

func (r ApiDevicesListRequest) SnOrName(snOrName string) ApiDevicesListRequest {
	r.snOrName = &snOrName
	return r
}

func (r ApiDevicesListRequest) SnOrNameIsnull(snOrNameIsnull bool) ApiDevicesListRequest {
	r.snOrNameIsnull = &snOrNameIsnull
	return r
}

func (r ApiDevicesListRequest) Status(status string) ApiDevicesListRequest {
	r.status = &status
	return r
}

func (r ApiDevicesListRequest) Uri(uri string) ApiDevicesListRequest {
	r.uri = &uri
	return r
}

func (r ApiDevicesListRequest) UriIsnull(uriIsnull bool) ApiDevicesListRequest {
	r.uriIsnull = &uriIsnull
	return r
}

func (r ApiDevicesListRequest) WstkPart(wstkPart string) ApiDevicesListRequest {
	r.wstkPart = &wstkPart
	return r
}

func (r ApiDevicesListRequest) Execute() (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	return r.ApiService.DevicesListExecute(r)
}

/*
DevicesList Method for DevicesList

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDevicesListRequest
*/
func (a *DevicesApiService) DevicesList(ctx context.Context) ApiDevicesListRequest {
	return ApiDevicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceSerializerPublicList
func (a *DevicesApiService) DevicesListExecute(r ApiDevicesListRequest) (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceSerializerPublicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateCreated != nil {
		localVarQueryParams.Add("date_created", parameterToString(*r.dateCreated, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.isWstk != nil {
		localVarQueryParams.Add("is_wstk", parameterToString(*r.isWstk, ""))
	}
	if r.lastUpdate != nil {
		localVarQueryParams.Add("last_update", parameterToString(*r.lastUpdate, ""))
	}
	if r.online != nil {
		localVarQueryParams.Add("online", parameterToString(*r.online, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.part != nil {
		localVarQueryParams.Add("part", parameterToString(*r.part, ""))
	}
	if r.partFamily != nil {
		localVarQueryParams.Add("part_family", parameterToString(*r.partFamily, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.snOrName != nil {
		localVarQueryParams.Add("sn_or_name", parameterToString(*r.snOrName, ""))
	}
	if r.snOrNameIsnull != nil {
		localVarQueryParams.Add("sn_or_name__isnull", parameterToString(*r.snOrNameIsnull, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.uri != nil {
		localVarQueryParams.Add("uri", parameterToString(*r.uri, ""))
	}
	if r.uriIsnull != nil {
		localVarQueryParams.Add("uri__isnull", parameterToString(*r.uriIsnull, ""))
	}
	if r.wstkPart != nil {
		localVarQueryParams.Add("wstk_part", parameterToString(*r.wstkPart, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesListMyListRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	dateCreated *time.Time
	idIn *[]string
	isWstk *bool
	lastUpdate *time.Time
	online *bool
	ordering *string
	page *int32
	part *string
	partFamily *string
	room *string
	search *string
	site *string
	snOrName *string
	snOrNameIsnull *bool
	status *string
	uri *string
	uriIsnull *bool
	wstkPart *string
}

func (r ApiDevicesListMyListRequest) DateCreated(dateCreated time.Time) ApiDevicesListMyListRequest {
	r.dateCreated = &dateCreated
	return r
}

// Multiple values may be separated by commas.
func (r ApiDevicesListMyListRequest) IdIn(idIn []string) ApiDevicesListMyListRequest {
	r.idIn = &idIn
	return r
}

func (r ApiDevicesListMyListRequest) IsWstk(isWstk bool) ApiDevicesListMyListRequest {
	r.isWstk = &isWstk
	return r
}

func (r ApiDevicesListMyListRequest) LastUpdate(lastUpdate time.Time) ApiDevicesListMyListRequest {
	r.lastUpdate = &lastUpdate
	return r
}

func (r ApiDevicesListMyListRequest) Online(online bool) ApiDevicesListMyListRequest {
	r.online = &online
	return r
}

// Which field to use when ordering the results.
func (r ApiDevicesListMyListRequest) Ordering(ordering string) ApiDevicesListMyListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiDevicesListMyListRequest) Page(page int32) ApiDevicesListMyListRequest {
	r.page = &page
	return r
}

func (r ApiDevicesListMyListRequest) Part(part string) ApiDevicesListMyListRequest {
	r.part = &part
	return r
}

func (r ApiDevicesListMyListRequest) PartFamily(partFamily string) ApiDevicesListMyListRequest {
	r.partFamily = &partFamily
	return r
}

func (r ApiDevicesListMyListRequest) Room(room string) ApiDevicesListMyListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiDevicesListMyListRequest) Search(search string) ApiDevicesListMyListRequest {
	r.search = &search
	return r
}

func (r ApiDevicesListMyListRequest) Site(site string) ApiDevicesListMyListRequest {
	r.site = &site
	return r
}

func (r ApiDevicesListMyListRequest) SnOrName(snOrName string) ApiDevicesListMyListRequest {
	r.snOrName = &snOrName
	return r
}

func (r ApiDevicesListMyListRequest) SnOrNameIsnull(snOrNameIsnull bool) ApiDevicesListMyListRequest {
	r.snOrNameIsnull = &snOrNameIsnull
	return r
}

func (r ApiDevicesListMyListRequest) Status(status string) ApiDevicesListMyListRequest {
	r.status = &status
	return r
}

func (r ApiDevicesListMyListRequest) Uri(uri string) ApiDevicesListMyListRequest {
	r.uri = &uri
	return r
}

func (r ApiDevicesListMyListRequest) UriIsnull(uriIsnull bool) ApiDevicesListMyListRequest {
	r.uriIsnull = &uriIsnull
	return r
}

func (r ApiDevicesListMyListRequest) WstkPart(wstkPart string) ApiDevicesListMyListRequest {
	r.wstkPart = &wstkPart
	return r
}

func (r ApiDevicesListMyListRequest) Execute() (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	return r.ApiService.DevicesListMyListExecute(r)
}

/*
DevicesListMyList Method for DevicesListMyList

Get devices owned by authenticated user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDevicesListMyListRequest
*/
func (a *DevicesApiService) DevicesListMyList(ctx context.Context) ApiDevicesListMyListRequest {
	return ApiDevicesListMyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceSerializerPublicList
func (a *DevicesApiService) DevicesListMyListExecute(r ApiDevicesListMyListRequest) (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceSerializerPublicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesListMyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/list_my/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dateCreated != nil {
		localVarQueryParams.Add("date_created", parameterToString(*r.dateCreated, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.isWstk != nil {
		localVarQueryParams.Add("is_wstk", parameterToString(*r.isWstk, ""))
	}
	if r.lastUpdate != nil {
		localVarQueryParams.Add("last_update", parameterToString(*r.lastUpdate, ""))
	}
	if r.online != nil {
		localVarQueryParams.Add("online", parameterToString(*r.online, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.part != nil {
		localVarQueryParams.Add("part", parameterToString(*r.part, ""))
	}
	if r.partFamily != nil {
		localVarQueryParams.Add("part_family", parameterToString(*r.partFamily, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.snOrName != nil {
		localVarQueryParams.Add("sn_or_name", parameterToString(*r.snOrName, ""))
	}
	if r.snOrNameIsnull != nil {
		localVarQueryParams.Add("sn_or_name__isnull", parameterToString(*r.snOrNameIsnull, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.uri != nil {
		localVarQueryParams.Add("uri", parameterToString(*r.uri, ""))
	}
	if r.uriIsnull != nil {
		localVarQueryParams.Add("uri__isnull", parameterToString(*r.uriIsnull, ""))
	}
	if r.wstkPart != nil {
		localVarQueryParams.Add("wstk_part", parameterToString(*r.wstkPart, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesLocationRetrieveRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	devicePk string
}

func (r ApiDevicesLocationRetrieveRequest) Execute() (*Location, *http.Response, error) {
	return r.ApiService.DevicesLocationRetrieveExecute(r)
}

/*
DevicesLocationRetrieve Method for DevicesLocationRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param devicePk
 @return ApiDevicesLocationRetrieveRequest
*/
func (a *DevicesApiService) DevicesLocationRetrieve(ctx context.Context, devicePk string) ApiDevicesLocationRetrieveRequest {
	return ApiDevicesLocationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		devicePk: devicePk,
	}
}

// Execute executes the request
//  @return Location
func (a *DevicesApiService) DevicesLocationRetrieveExecute(r ApiDevicesLocationRetrieveRequest) (*Location, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Location
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesLocationRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{device_pk}/location/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_pk"+"}", url.PathEscape(parameterToString(r.devicePk, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	patchedWriteOnlyDevice *PatchedWriteOnlyDevice
}

func (r ApiDevicesPartialUpdateRequest) PatchedWriteOnlyDevice(patchedWriteOnlyDevice PatchedWriteOnlyDevice) ApiDevicesPartialUpdateRequest {
	r.patchedWriteOnlyDevice = &patchedWriteOnlyDevice
	return r
}

func (r ApiDevicesPartialUpdateRequest) Execute() (*WriteOnlyDevice, *http.Response, error) {
	return r.ApiService.DevicesPartialUpdateExecute(r)
}

/*
DevicesPartialUpdate Method for DevicesPartialUpdate

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesPartialUpdateRequest
*/
func (a *DevicesApiService) DevicesPartialUpdate(ctx context.Context, id int32) ApiDevicesPartialUpdateRequest {
	return ApiDevicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WriteOnlyDevice
func (a *DevicesApiService) DevicesPartialUpdateExecute(r ApiDevicesPartialUpdateRequest) (*WriteOnlyDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WriteOnlyDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWriteOnlyDevice
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesPermissionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	patchedObjectPermissions *PatchedObjectPermissions
}

func (r ApiDevicesPermissionsPartialUpdateRequest) PatchedObjectPermissions(patchedObjectPermissions PatchedObjectPermissions) ApiDevicesPermissionsPartialUpdateRequest {
	r.patchedObjectPermissions = &patchedObjectPermissions
	return r
}

func (r ApiDevicesPermissionsPartialUpdateRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.DevicesPermissionsPartialUpdateExecute(r)
}

/*
DevicesPermissionsPartialUpdate Method for DevicesPermissionsPartialUpdate

Partially update the object-level permissions for this resource.
Can omit top-level fields to leave unchanged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesPermissionsPartialUpdateRequest
*/
func (a *DevicesApiService) DevicesPermissionsPartialUpdate(ctx context.Context, id int32) ApiDevicesPermissionsPartialUpdateRequest {
	return ApiDevicesPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *DevicesApiService) DevicesPermissionsPartialUpdateExecute(r ApiDevicesPermissionsPartialUpdateRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedObjectPermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesPermissionsRetrieveRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
}

func (r ApiDevicesPermissionsRetrieveRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.DevicesPermissionsRetrieveExecute(r)
}

/*
DevicesPermissionsRetrieve Method for DevicesPermissionsRetrieve

Get the object-level permissions for this resource. Will return
user permissions and user group permissions separately. User permissions
 will not include those derived from user group membership.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesPermissionsRetrieveRequest
*/
func (a *DevicesApiService) DevicesPermissionsRetrieve(ctx context.Context, id int32) ApiDevicesPermissionsRetrieveRequest {
	return ApiDevicesPermissionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *DevicesApiService) DevicesPermissionsRetrieveExecute(r ApiDevicesPermissionsRetrieveRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesPermissionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesPermissionsUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	objectPermissions *ObjectPermissions
}

func (r ApiDevicesPermissionsUpdateRequest) ObjectPermissions(objectPermissions ObjectPermissions) ApiDevicesPermissionsUpdateRequest {
	r.objectPermissions = &objectPermissions
	return r
}

func (r ApiDevicesPermissionsUpdateRequest) Execute() (*ObjectPermissions, *http.Response, error) {
	return r.ApiService.DevicesPermissionsUpdateExecute(r)
}

/*
DevicesPermissionsUpdate Method for DevicesPermissionsUpdate

Update the object-level permissions for this resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesPermissionsUpdateRequest
*/
func (a *DevicesApiService) DevicesPermissionsUpdate(ctx context.Context, id int32) ApiDevicesPermissionsUpdateRequest {
	return ApiDevicesPermissionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectPermissions
func (a *DevicesApiService) DevicesPermissionsUpdateExecute(r ApiDevicesPermissionsUpdateRequest) (*ObjectPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectPermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectPermissions == nil {
		return localVarReturnValue, nil, reportError("objectPermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectPermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesReleaseUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
}

func (r ApiDevicesReleaseUpdateRequest) Execute() (*DeviceSerializerPublic, *http.Response, error) {
	return r.ApiService.DevicesReleaseUpdateExecute(r)
}

/*
DevicesReleaseUpdate Method for DevicesReleaseUpdate

Release a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesReleaseUpdateRequest
*/
func (a *DevicesApiService) DevicesReleaseUpdate(ctx context.Context, id int32) ApiDevicesReleaseUpdateRequest {
	return ApiDevicesReleaseUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceSerializerPublic
func (a *DevicesApiService) DevicesReleaseUpdateExecute(r ApiDevicesReleaseUpdateRequest) (*DeviceSerializerPublic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceSerializerPublic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesReleaseUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/release/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesReserveUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	details *string
}

// Additional information such as the jenkins job URL
func (r ApiDevicesReserveUpdateRequest) Details(details string) ApiDevicesReserveUpdateRequest {
	r.details = &details
	return r
}

func (r ApiDevicesReserveUpdateRequest) Execute() (*DeviceSerializerPublic, *http.Response, error) {
	return r.ApiService.DevicesReserveUpdateExecute(r)
}

/*
DevicesReserveUpdate Method for DevicesReserveUpdate

Reserve a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesReserveUpdateRequest
*/
func (a *DevicesApiService) DevicesReserveUpdate(ctx context.Context, id int32) ApiDevicesReserveUpdateRequest {
	return ApiDevicesReserveUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceSerializerPublic
func (a *DevicesApiService) DevicesReserveUpdateExecute(r ApiDevicesReserveUpdateRequest) (*DeviceSerializerPublic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceSerializerPublic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesReserveUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/reserve/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.details != nil {
		localVarQueryParams.Add("details", parameterToString(*r.details, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesRetrieveRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
}

func (r ApiDevicesRetrieveRequest) Execute() (*DeviceSerializerPublic, *http.Response, error) {
	return r.ApiService.DevicesRetrieveExecute(r)
}

/*
DevicesRetrieve Method for DevicesRetrieve

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesRetrieveRequest
*/
func (a *DevicesApiService) DevicesRetrieve(ctx context.Context, id int32) ApiDevicesRetrieveRequest {
	return ApiDevicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeviceSerializerPublic
func (a *DevicesApiService) DevicesRetrieveExecute(r ApiDevicesRetrieveRequest) (*DeviceSerializerPublic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeviceSerializerPublic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesSearchListRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	searchKeyValuePairs *string
	dateCreated *time.Time
	idIn *[]string
	isWstk *bool
	lastUpdate *time.Time
	online *bool
	ordering *string
	page *int32
	part *string
	partFamily *string
	room *string
	search *string
	site *string
	snOrName *string
	snOrNameIsnull *bool
	status *string
	uri *string
	uriIsnull *bool
	wstkPart *string
}

func (r ApiDevicesSearchListRequest) SearchKeyValuePairs(searchKeyValuePairs string) ApiDevicesSearchListRequest {
	r.searchKeyValuePairs = &searchKeyValuePairs
	return r
}

func (r ApiDevicesSearchListRequest) DateCreated(dateCreated time.Time) ApiDevicesSearchListRequest {
	r.dateCreated = &dateCreated
	return r
}

// Multiple values may be separated by commas.
func (r ApiDevicesSearchListRequest) IdIn(idIn []string) ApiDevicesSearchListRequest {
	r.idIn = &idIn
	return r
}

func (r ApiDevicesSearchListRequest) IsWstk(isWstk bool) ApiDevicesSearchListRequest {
	r.isWstk = &isWstk
	return r
}

func (r ApiDevicesSearchListRequest) LastUpdate(lastUpdate time.Time) ApiDevicesSearchListRequest {
	r.lastUpdate = &lastUpdate
	return r
}

func (r ApiDevicesSearchListRequest) Online(online bool) ApiDevicesSearchListRequest {
	r.online = &online
	return r
}

// Which field to use when ordering the results.
func (r ApiDevicesSearchListRequest) Ordering(ordering string) ApiDevicesSearchListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiDevicesSearchListRequest) Page(page int32) ApiDevicesSearchListRequest {
	r.page = &page
	return r
}

func (r ApiDevicesSearchListRequest) Part(part string) ApiDevicesSearchListRequest {
	r.part = &part
	return r
}

func (r ApiDevicesSearchListRequest) PartFamily(partFamily string) ApiDevicesSearchListRequest {
	r.partFamily = &partFamily
	return r
}

func (r ApiDevicesSearchListRequest) Room(room string) ApiDevicesSearchListRequest {
	r.room = &room
	return r
}

// A search term.
func (r ApiDevicesSearchListRequest) Search(search string) ApiDevicesSearchListRequest {
	r.search = &search
	return r
}

func (r ApiDevicesSearchListRequest) Site(site string) ApiDevicesSearchListRequest {
	r.site = &site
	return r
}

func (r ApiDevicesSearchListRequest) SnOrName(snOrName string) ApiDevicesSearchListRequest {
	r.snOrName = &snOrName
	return r
}

func (r ApiDevicesSearchListRequest) SnOrNameIsnull(snOrNameIsnull bool) ApiDevicesSearchListRequest {
	r.snOrNameIsnull = &snOrNameIsnull
	return r
}

func (r ApiDevicesSearchListRequest) Status(status string) ApiDevicesSearchListRequest {
	r.status = &status
	return r
}

func (r ApiDevicesSearchListRequest) Uri(uri string) ApiDevicesSearchListRequest {
	r.uri = &uri
	return r
}

func (r ApiDevicesSearchListRequest) UriIsnull(uriIsnull bool) ApiDevicesSearchListRequest {
	r.uriIsnull = &uriIsnull
	return r
}

func (r ApiDevicesSearchListRequest) WstkPart(wstkPart string) ApiDevicesSearchListRequest {
	r.wstkPart = &wstkPart
	return r
}

func (r ApiDevicesSearchListRequest) Execute() (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	return r.ApiService.DevicesSearchListExecute(r)
}

/*
DevicesSearchList Method for DevicesSearchList

Search by any key-value pair in the device. Search includes nested key-value pairs in the metadata or any other fields in the serialized representation of the device.

Comparison operations can be specified by doing: key__{oper}=value. Supported operations:

eq: equals, neq: not equals, re: regular expression, gt: greater than, gte, greater than or equals, lt: less than, lte, less than or equals, in: contains

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDevicesSearchListRequest
*/
func (a *DevicesApiService) DevicesSearchList(ctx context.Context) ApiDevicesSearchListRequest {
	return ApiDevicesSearchListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedDeviceSerializerPublicList
func (a *DevicesApiService) DevicesSearchListExecute(r ApiDevicesSearchListRequest) (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceSerializerPublicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesSearchList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/search/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchKeyValuePairs == nil {
		return localVarReturnValue, nil, reportError("searchKeyValuePairs is required and must be specified")
	}

	if r.dateCreated != nil {
		localVarQueryParams.Add("date_created", parameterToString(*r.dateCreated, ""))
	}
	if r.idIn != nil {
		localVarQueryParams.Add("id__in", parameterToString(*r.idIn, "csv"))
	}
	if r.isWstk != nil {
		localVarQueryParams.Add("is_wstk", parameterToString(*r.isWstk, ""))
	}
	if r.lastUpdate != nil {
		localVarQueryParams.Add("last_update", parameterToString(*r.lastUpdate, ""))
	}
	if r.online != nil {
		localVarQueryParams.Add("online", parameterToString(*r.online, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.part != nil {
		localVarQueryParams.Add("part", parameterToString(*r.part, ""))
	}
	if r.partFamily != nil {
		localVarQueryParams.Add("part_family", parameterToString(*r.partFamily, ""))
	}
	if r.room != nil {
		localVarQueryParams.Add("room", parameterToString(*r.room, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	localVarQueryParams.Add("search_key_value_pairs", parameterToString(*r.searchKeyValuePairs, ""))
	if r.site != nil {
		localVarQueryParams.Add("site", parameterToString(*r.site, ""))
	}
	if r.snOrName != nil {
		localVarQueryParams.Add("sn_or_name", parameterToString(*r.snOrName, ""))
	}
	if r.snOrNameIsnull != nil {
		localVarQueryParams.Add("sn_or_name__isnull", parameterToString(*r.snOrNameIsnull, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.uri != nil {
		localVarQueryParams.Add("uri", parameterToString(*r.uri, ""))
	}
	if r.uriIsnull != nil {
		localVarQueryParams.Add("uri__isnull", parameterToString(*r.uriIsnull, ""))
	}
	if r.wstkPart != nil {
		localVarQueryParams.Add("wstk_part", parameterToString(*r.wstkPart, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesSetOfflineCreateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	writeOnlyDevice *WriteOnlyDevice
}

func (r ApiDevicesSetOfflineCreateRequest) WriteOnlyDevice(writeOnlyDevice WriteOnlyDevice) ApiDevicesSetOfflineCreateRequest {
	r.writeOnlyDevice = &writeOnlyDevice
	return r
}

func (r ApiDevicesSetOfflineCreateRequest) Execute() (*WriteOnlyDevice, *http.Response, error) {
	return r.ApiService.DevicesSetOfflineCreateExecute(r)
}

/*
DevicesSetOfflineCreate Method for DevicesSetOfflineCreate

Sets all devices offline which haven't been updated
in the last hour

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDevicesSetOfflineCreateRequest
*/
func (a *DevicesApiService) DevicesSetOfflineCreate(ctx context.Context) ApiDevicesSetOfflineCreateRequest {
	return ApiDevicesSetOfflineCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WriteOnlyDevice
func (a *DevicesApiService) DevicesSetOfflineCreateExecute(r ApiDevicesSetOfflineCreateRequest) (*WriteOnlyDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WriteOnlyDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesSetOfflineCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/set_offline/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writeOnlyDevice == nil {
		return localVarReturnValue, nil, reportError("writeOnlyDevice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writeOnlyDevice
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesStatusCreateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	resourceStatusRequest *ResourceStatusRequest
}

func (r ApiDevicesStatusCreateRequest) ResourceStatusRequest(resourceStatusRequest ResourceStatusRequest) ApiDevicesStatusCreateRequest {
	r.resourceStatusRequest = &resourceStatusRequest
	return r
}

func (r ApiDevicesStatusCreateRequest) Execute() (*ResourceStatusRequest, *http.Response, error) {
	return r.ApiService.DevicesStatusCreateExecute(r)
}

/*
DevicesStatusCreate Method for DevicesStatusCreate

Modify the device status.
A comment is required unless the new status is ACTIVE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesStatusCreateRequest
*/
func (a *DevicesApiService) DevicesStatusCreate(ctx context.Context, id int32) ApiDevicesStatusCreateRequest {
	return ApiDevicesStatusCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceStatusRequest
func (a *DevicesApiService) DevicesStatusCreateExecute(r ApiDevicesStatusCreateRequest) (*ResourceStatusRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceStatusRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesStatusCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/status/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourceStatusRequest == nil {
		return localVarReturnValue, nil, reportError("resourceStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDevicesUpdateRequest struct {
	ctx context.Context
	ApiService *DevicesApiService
	id int32
	writeOnlyDevice *WriteOnlyDevice
}

func (r ApiDevicesUpdateRequest) WriteOnlyDevice(writeOnlyDevice WriteOnlyDevice) ApiDevicesUpdateRequest {
	r.writeOnlyDevice = &writeOnlyDevice
	return r
}

func (r ApiDevicesUpdateRequest) Execute() (*WriteOnlyDevice, *http.Response, error) {
	return r.ApiService.DevicesUpdateExecute(r)
}

/*
DevicesUpdate Method for DevicesUpdate

Create or update with permissions field support

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this device.
 @return ApiDevicesUpdateRequest
*/
func (a *DevicesApiService) DevicesUpdate(ctx context.Context, id int32) ApiDevicesUpdateRequest {
	return ApiDevicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WriteOnlyDevice
func (a *DevicesApiService) DevicesUpdateExecute(r ApiDevicesUpdateRequest) (*WriteOnlyDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WriteOnlyDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DevicesApiService.DevicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writeOnlyDevice == nil {
		return localVarReturnValue, nil, reportError("writeOnlyDevice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writeOnlyDevice
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
