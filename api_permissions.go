/*
HW Mux Reservation System

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.5.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PermissionsApiService PermissionsApi service
type PermissionsApiService service

type ApiPermissionsGroupsCreateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	permissionGroup *PermissionGroup
}

func (r ApiPermissionsGroupsCreateRequest) PermissionGroup(permissionGroup PermissionGroup) ApiPermissionsGroupsCreateRequest {
	r.permissionGroup = &permissionGroup
	return r
}

func (r ApiPermissionsGroupsCreateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsCreateExecute(r)
}

/*
PermissionsGroupsCreate Method for PermissionsGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPermissionsGroupsCreateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsCreate(ctx context.Context) ApiPermissionsGroupsCreateRequest {
	return ApiPermissionsGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsCreateExecute(r ApiPermissionsGroupsCreateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.permissionGroup == nil {
		return localVarReturnValue, nil, reportError("permissionGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.permissionGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDeviceGroupsCreateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	resourcePermissions *[]ResourcePermissions
}

func (r ApiPermissionsGroupsDeviceGroupsCreateRequest) ResourcePermissions(resourcePermissions []ResourcePermissions) ApiPermissionsGroupsDeviceGroupsCreateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsDeviceGroupsCreateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDeviceGroupsCreateExecute(r)
}

/*
PermissionsGroupsDeviceGroupsCreate Method for PermissionsGroupsDeviceGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsDeviceGroupsCreateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsCreate(ctx context.Context, groupName string) ApiPermissionsGroupsDeviceGroupsCreateRequest {
	return ApiPermissionsGroupsDeviceGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsCreateExecute(r ApiPermissionsGroupsDeviceGroupsCreateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDeviceGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/device_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDeviceGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
}

func (r ApiPermissionsGroupsDeviceGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PermissionsGroupsDeviceGroupsDestroyExecute(r)
}

/*
PermissionsGroupsDeviceGroupsDestroy Method for PermissionsGroupsDeviceGroupsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group.
 @return ApiPermissionsGroupsDeviceGroupsDestroyRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsDestroy(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDeviceGroupsDestroyRequest {
	return ApiPermissionsGroupsDeviceGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsDestroyExecute(r ApiPermissionsGroupsDeviceGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDeviceGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/device_groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDeviceGroupsListRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	page *int32
	perms *string
}

// A page number within the paginated result set.
func (r ApiPermissionsGroupsDeviceGroupsListRequest) Page(page int32) ApiPermissionsGroupsDeviceGroupsListRequest {
	r.page = &page
	return r
}

// Permission types. Only entities with all permissions defined here will be fetched. Defaults to all permissions.
func (r ApiPermissionsGroupsDeviceGroupsListRequest) Perms(perms string) ApiPermissionsGroupsDeviceGroupsListRequest {
	r.perms = &perms
	return r
}

func (r ApiPermissionsGroupsDeviceGroupsListRequest) Execute() (*PaginatedDeviceGroupList, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDeviceGroupsListExecute(r)
}

/*
PermissionsGroupsDeviceGroupsList Method for PermissionsGroupsDeviceGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsDeviceGroupsListRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsList(ctx context.Context, groupName string) ApiPermissionsGroupsDeviceGroupsListRequest {
	return ApiPermissionsGroupsDeviceGroupsListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PaginatedDeviceGroupList
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsListExecute(r ApiPermissionsGroupsDeviceGroupsListRequest) (*PaginatedDeviceGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDeviceGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/device_groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perms != nil {
		localVarQueryParams.Add("perms", parameterToString(*r.perms, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	patchedResourcePermissions *PatchedResourcePermissions
}

func (r ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest) PatchedResourcePermissions(patchedResourcePermissions PatchedResourcePermissions) ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest {
	r.patchedResourcePermissions = &patchedResourcePermissions
	return r
}

func (r ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest) Execute() (*ResourcePermissions, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDeviceGroupsPartialUpdateExecute(r)
}

/*
PermissionsGroupsDeviceGroupsPartialUpdate Method for PermissionsGroupsDeviceGroupsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group.
 @return ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsPartialUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest {
	return ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return ResourcePermissions
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsPartialUpdateExecute(r ApiPermissionsGroupsDeviceGroupsPartialUpdateRequest) (*ResourcePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourcePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDeviceGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/device_groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedResourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDeviceGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	resourcePermissions *ResourcePermissions
}

func (r ApiPermissionsGroupsDeviceGroupsUpdateRequest) ResourcePermissions(resourcePermissions ResourcePermissions) ApiPermissionsGroupsDeviceGroupsUpdateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsDeviceGroupsUpdateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDeviceGroupsUpdateExecute(r)
}

/*
PermissionsGroupsDeviceGroupsUpdate Method for PermissionsGroupsDeviceGroupsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group.
 @return ApiPermissionsGroupsDeviceGroupsUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDeviceGroupsUpdateRequest {
	return ApiPermissionsGroupsDeviceGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsDeviceGroupsUpdateExecute(r ApiPermissionsGroupsDeviceGroupsUpdateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDeviceGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/device_groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDevicesCreateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	resourcePermissions *[]ResourcePermissions
}

func (r ApiPermissionsGroupsDevicesCreateRequest) ResourcePermissions(resourcePermissions []ResourcePermissions) ApiPermissionsGroupsDevicesCreateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsDevicesCreateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDevicesCreateExecute(r)
}

/*
PermissionsGroupsDevicesCreate Method for PermissionsGroupsDevicesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsDevicesCreateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDevicesCreate(ctx context.Context, groupName string) ApiPermissionsGroupsDevicesCreateRequest {
	return ApiPermissionsGroupsDevicesCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsDevicesCreateExecute(r ApiPermissionsGroupsDevicesCreateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDevicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/devices/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDevicesDestroyRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
}

func (r ApiPermissionsGroupsDevicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PermissionsGroupsDevicesDestroyExecute(r)
}

/*
PermissionsGroupsDevicesDestroy Method for PermissionsGroupsDevicesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device.
 @return ApiPermissionsGroupsDevicesDestroyRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDevicesDestroy(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDevicesDestroyRequest {
	return ApiPermissionsGroupsDevicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
func (a *PermissionsApiService) PermissionsGroupsDevicesDestroyExecute(r ApiPermissionsGroupsDevicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDevicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDevicesListRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	page *int32
	perms *string
}

// A page number within the paginated result set.
func (r ApiPermissionsGroupsDevicesListRequest) Page(page int32) ApiPermissionsGroupsDevicesListRequest {
	r.page = &page
	return r
}

// Permission types. Only entities with all permissions defined here will be fetched. Defaults to all permissions.
func (r ApiPermissionsGroupsDevicesListRequest) Perms(perms string) ApiPermissionsGroupsDevicesListRequest {
	r.perms = &perms
	return r
}

func (r ApiPermissionsGroupsDevicesListRequest) Execute() (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDevicesListExecute(r)
}

/*
PermissionsGroupsDevicesList Method for PermissionsGroupsDevicesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsDevicesListRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDevicesList(ctx context.Context, groupName string) ApiPermissionsGroupsDevicesListRequest {
	return ApiPermissionsGroupsDevicesListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PaginatedDeviceSerializerPublicList
func (a *PermissionsApiService) PermissionsGroupsDevicesListExecute(r ApiPermissionsGroupsDevicesListRequest) (*PaginatedDeviceSerializerPublicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeviceSerializerPublicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDevicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/devices/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perms != nil {
		localVarQueryParams.Add("perms", parameterToString(*r.perms, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDevicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	patchedResourcePermissions *PatchedResourcePermissions
}

func (r ApiPermissionsGroupsDevicesPartialUpdateRequest) PatchedResourcePermissions(patchedResourcePermissions PatchedResourcePermissions) ApiPermissionsGroupsDevicesPartialUpdateRequest {
	r.patchedResourcePermissions = &patchedResourcePermissions
	return r
}

func (r ApiPermissionsGroupsDevicesPartialUpdateRequest) Execute() (*ResourcePermissions, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDevicesPartialUpdateExecute(r)
}

/*
PermissionsGroupsDevicesPartialUpdate Method for PermissionsGroupsDevicesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device.
 @return ApiPermissionsGroupsDevicesPartialUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDevicesPartialUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDevicesPartialUpdateRequest {
	return ApiPermissionsGroupsDevicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return ResourcePermissions
func (a *PermissionsApiService) PermissionsGroupsDevicesPartialUpdateExecute(r ApiPermissionsGroupsDevicesPartialUpdateRequest) (*ResourcePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourcePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDevicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedResourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsDevicesUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	resourcePermissions *ResourcePermissions
}

func (r ApiPermissionsGroupsDevicesUpdateRequest) ResourcePermissions(resourcePermissions ResourcePermissions) ApiPermissionsGroupsDevicesUpdateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsDevicesUpdateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsDevicesUpdateExecute(r)
}

/*
PermissionsGroupsDevicesUpdate Method for PermissionsGroupsDevicesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device.
 @return ApiPermissionsGroupsDevicesUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsDevicesUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsDevicesUpdateRequest {
	return ApiPermissionsGroupsDevicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsDevicesUpdateExecute(r ApiPermissionsGroupsDevicesUpdateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsDevicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsLabelsCreateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	resourcePermissions *[]ResourcePermissions
}

func (r ApiPermissionsGroupsLabelsCreateRequest) ResourcePermissions(resourcePermissions []ResourcePermissions) ApiPermissionsGroupsLabelsCreateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsLabelsCreateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsLabelsCreateExecute(r)
}

/*
PermissionsGroupsLabelsCreate Method for PermissionsGroupsLabelsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsLabelsCreateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsLabelsCreate(ctx context.Context, groupName string) ApiPermissionsGroupsLabelsCreateRequest {
	return ApiPermissionsGroupsLabelsCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsLabelsCreateExecute(r ApiPermissionsGroupsLabelsCreateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsLabelsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsLabelsDestroyRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
}

func (r ApiPermissionsGroupsLabelsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PermissionsGroupsLabelsDestroyExecute(r)
}

/*
PermissionsGroupsLabelsDestroy Method for PermissionsGroupsLabelsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group label.
 @return ApiPermissionsGroupsLabelsDestroyRequest
*/
func (a *PermissionsApiService) PermissionsGroupsLabelsDestroy(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsLabelsDestroyRequest {
	return ApiPermissionsGroupsLabelsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
func (a *PermissionsApiService) PermissionsGroupsLabelsDestroyExecute(r ApiPermissionsGroupsLabelsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsLabelsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/labels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPermissionsGroupsLabelsListRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	page *int32
	perms *string
}

// A page number within the paginated result set.
func (r ApiPermissionsGroupsLabelsListRequest) Page(page int32) ApiPermissionsGroupsLabelsListRequest {
	r.page = &page
	return r
}

// Permission types. Only entities with all permissions defined here will be fetched. Defaults to all permissions.
func (r ApiPermissionsGroupsLabelsListRequest) Perms(perms string) ApiPermissionsGroupsLabelsListRequest {
	r.perms = &perms
	return r
}

func (r ApiPermissionsGroupsLabelsListRequest) Execute() (*PaginatedLabelList, *http.Response, error) {
	return r.ApiService.PermissionsGroupsLabelsListExecute(r)
}

/*
PermissionsGroupsLabelsList Method for PermissionsGroupsLabelsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsLabelsListRequest
*/
func (a *PermissionsApiService) PermissionsGroupsLabelsList(ctx context.Context, groupName string) ApiPermissionsGroupsLabelsListRequest {
	return ApiPermissionsGroupsLabelsListRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PaginatedLabelList
func (a *PermissionsApiService) PermissionsGroupsLabelsListExecute(r ApiPermissionsGroupsLabelsListRequest) (*PaginatedLabelList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLabelList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsLabelsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/labels/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.perms != nil {
		localVarQueryParams.Add("perms", parameterToString(*r.perms, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsLabelsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	patchedResourcePermissions *PatchedResourcePermissions
}

func (r ApiPermissionsGroupsLabelsPartialUpdateRequest) PatchedResourcePermissions(patchedResourcePermissions PatchedResourcePermissions) ApiPermissionsGroupsLabelsPartialUpdateRequest {
	r.patchedResourcePermissions = &patchedResourcePermissions
	return r
}

func (r ApiPermissionsGroupsLabelsPartialUpdateRequest) Execute() (*ResourcePermissions, *http.Response, error) {
	return r.ApiService.PermissionsGroupsLabelsPartialUpdateExecute(r)
}

/*
PermissionsGroupsLabelsPartialUpdate Method for PermissionsGroupsLabelsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group label.
 @return ApiPermissionsGroupsLabelsPartialUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsLabelsPartialUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsLabelsPartialUpdateRequest {
	return ApiPermissionsGroupsLabelsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return ResourcePermissions
func (a *PermissionsApiService) PermissionsGroupsLabelsPartialUpdateExecute(r ApiPermissionsGroupsLabelsPartialUpdateRequest) (*ResourcePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourcePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsLabelsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/labels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedResourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsLabelsUpdateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	id int32
	resourcePermissions *ResourcePermissions
}

func (r ApiPermissionsGroupsLabelsUpdateRequest) ResourcePermissions(resourcePermissions ResourcePermissions) ApiPermissionsGroupsLabelsUpdateRequest {
	r.resourcePermissions = &resourcePermissions
	return r
}

func (r ApiPermissionsGroupsLabelsUpdateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsLabelsUpdateExecute(r)
}

/*
PermissionsGroupsLabelsUpdate Method for PermissionsGroupsLabelsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param id A unique integer value identifying this device group label.
 @return ApiPermissionsGroupsLabelsUpdateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsLabelsUpdate(ctx context.Context, groupName string, id int32) ApiPermissionsGroupsLabelsUpdateRequest {
	return ApiPermissionsGroupsLabelsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		id: id,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsLabelsUpdateExecute(r ApiPermissionsGroupsLabelsUpdateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsLabelsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/labels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourcePermissions == nil {
		return localVarReturnValue, nil, reportError("resourcePermissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourcePermissions
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsListRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	ordering *string
	page *int32
	search *string
}

// Which field to use when ordering the results.
func (r ApiPermissionsGroupsListRequest) Ordering(ordering string) ApiPermissionsGroupsListRequest {
	r.ordering = &ordering
	return r
}

// A page number within the paginated result set.
func (r ApiPermissionsGroupsListRequest) Page(page int32) ApiPermissionsGroupsListRequest {
	r.page = &page
	return r
}

// A search term.
func (r ApiPermissionsGroupsListRequest) Search(search string) ApiPermissionsGroupsListRequest {
	r.search = &search
	return r
}

func (r ApiPermissionsGroupsListRequest) Execute() (*PaginatedPermissionGroupList, *http.Response, error) {
	return r.ApiService.PermissionsGroupsListExecute(r)
}

/*
PermissionsGroupsList Method for PermissionsGroupsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPermissionsGroupsListRequest
*/
func (a *PermissionsApiService) PermissionsGroupsList(ctx context.Context) ApiPermissionsGroupsListRequest {
	return ApiPermissionsGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPermissionGroupList
func (a *PermissionsApiService) PermissionsGroupsListExecute(r ApiPermissionsGroupsListRequest) (*PaginatedPermissionGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPermissionGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	name string
}

func (r ApiPermissionsGroupsRetrieveRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsRetrieveExecute(r)
}

/*
PermissionsGroupsRetrieve Method for PermissionsGroupsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiPermissionsGroupsRetrieveRequest
*/
func (a *PermissionsApiService) PermissionsGroupsRetrieve(ctx context.Context, name string) ApiPermissionsGroupsRetrieveRequest {
	return ApiPermissionsGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsRetrieveExecute(r ApiPermissionsGroupsRetrieveRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsUsersCreateRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	user *[]User
}

func (r ApiPermissionsGroupsUsersCreateRequest) User(user []User) ApiPermissionsGroupsUsersCreateRequest {
	r.user = &user
	return r
}

func (r ApiPermissionsGroupsUsersCreateRequest) Execute() (*PermissionGroup, *http.Response, error) {
	return r.ApiService.PermissionsGroupsUsersCreateExecute(r)
}

/*
PermissionsGroupsUsersCreate Method for PermissionsGroupsUsersCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @return ApiPermissionsGroupsUsersCreateRequest
*/
func (a *PermissionsApiService) PermissionsGroupsUsersCreate(ctx context.Context, groupName string) ApiPermissionsGroupsUsersCreateRequest {
	return ApiPermissionsGroupsUsersCreateRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
	}
}

// Execute executes the request
//  @return PermissionGroup
func (a *PermissionsApiService) PermissionsGroupsUsersCreateExecute(r ApiPermissionsGroupsUsersCreateRequest) (*PermissionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PermissionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsUsersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/users/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.user == nil {
		return localVarReturnValue, nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPermissionsGroupsUsersDestroyRequest struct {
	ctx context.Context
	ApiService *PermissionsApiService
	groupName string
	username string
}

func (r ApiPermissionsGroupsUsersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PermissionsGroupsUsersDestroyExecute(r)
}

/*
PermissionsGroupsUsersDestroy Method for PermissionsGroupsUsersDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupName
 @param username
 @return ApiPermissionsGroupsUsersDestroyRequest
*/
func (a *PermissionsApiService) PermissionsGroupsUsersDestroy(ctx context.Context, groupName string, username string) ApiPermissionsGroupsUsersDestroyRequest {
	return ApiPermissionsGroupsUsersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		groupName: groupName,
		username: username,
	}
}

// Execute executes the request
func (a *PermissionsApiService) PermissionsGroupsUsersDestroyExecute(r ApiPermissionsGroupsUsersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PermissionsApiService.PermissionsGroupsUsersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/permissions/groups/{group_name}/users/{username}/"
	localVarPath = strings.Replace(localVarPath, "{"+"group_name"+"}", url.PathEscape(parameterToString(r.groupName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
